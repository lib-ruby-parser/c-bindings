/* Text to put at the beginning of the generated file. Probably a license. */

#ifndef LIB_RUBY_PARSER_C_BINDINGS_H
#define LIB_RUBY_PARSER_C_BINDINGS_H

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

struct LIB_RUBY_PARSER_Node;
typedef struct LIB_RUBY_PARSER_Node* LIB_RUBY_PARSER_MaybePtr_Node;
typedef struct LIB_RUBY_PARSER_Node* LIB_RUBY_PARSER_Ptr_Node;


// Token `` "end-of-input" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_END_OF_INPUT 0

// EXPR_ARG state in MRI
#define LIB_RUBY_PARSER_EXPR_ARG (1 << 4)

// EXPR_ARG_ANY state in MRI
#define LIB_RUBY_PARSER_EXPR_ARG_ANY (LIB_RUBY_PARSER_EXPR_ARG | LIB_RUBY_PARSER_EXPR_CMDARG)

// EXPR_BEG state in MRI
#define LIB_RUBY_PARSER_EXPR_BEG (1 << 0)

// EXPR_BEG_ANY state in MRI
#define LIB_RUBY_PARSER_EXPR_BEG_ANY ((LIB_RUBY_PARSER_EXPR_BEG | LIB_RUBY_PARSER_EXPR_MID) | LIB_RUBY_PARSER_EXPR_CLASS)

// EXPR_CLASS state in MRI
#define LIB_RUBY_PARSER_EXPR_CLASS (1 << 9)

// EXPR_CMDARG state in MRI
#define LIB_RUBY_PARSER_EXPR_CMDARG (1 << 5)

// EXPR_DOT state in MRI
#define LIB_RUBY_PARSER_EXPR_DOT (1 << 8)

// EXPR_END state in MRI
#define LIB_RUBY_PARSER_EXPR_END (1 << 1)

// EXPR_ENDARG state in MRI
#define LIB_RUBY_PARSER_EXPR_ENDARG (1 << 2)

// EXPR_ENDFN state in MRI
#define LIB_RUBY_PARSER_EXPR_ENDFN (1 << 3)

// EXPR_END_ANY state in MRI
#define LIB_RUBY_PARSER_EXPR_END_ANY ((LIB_RUBY_PARSER_EXPR_END | LIB_RUBY_PARSER_EXPR_ENDARG) | LIB_RUBY_PARSER_EXPR_ENDFN)

// EXPR_FITEM state in MRI
#define LIB_RUBY_PARSER_EXPR_FITEM (1 << 12)

// EXPR_FNAME state in MRI
#define LIB_RUBY_PARSER_EXPR_FNAME (1 << 7)

// EXPR_LABEL state in MRI
#define LIB_RUBY_PARSER_EXPR_LABEL (1 << 10)

// EXPR_LABELED state in MRI
#define LIB_RUBY_PARSER_EXPR_LABELED (1 << 11)

// EXPR_MID state in MRI
#define LIB_RUBY_PARSER_EXPR_MID (1 << 6)

// EXPR_NONE state in MRI
#define LIB_RUBY_PARSER_EXPR_NONE 0

// EXPR_VALUE state in MRI
#define LIB_RUBY_PARSER_EXPR_VALUE LIB_RUBY_PARSER_EXPR_BEG

// Token `` "invalid token" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_YYUNDEF 257

// Token `` error ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_YYerror 256

// Token `` "`alias'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kALIAS 300

// Token `` "`and'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kAND 292

// Token `` "`begin'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kBEGIN 262

// Token `` "`break'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kBREAK 276

// Token `` "`case'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kCASE 271

// Token `` "`class'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kCLASS 258

// Token `` "`def'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kDEF 260

// Token `` "`defined?'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kDEFINED 301

// Token `` "`do'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kDO 281

// Token `` "`do' for block" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kDO_BLOCK 283

// Token `` "`do' for condition" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kDO_COND 282

// Token `` "`do' for lambda" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kDO_LAMBDA 284

// Token `` "`else'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kELSE 270

// Token `` "`elsif'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kELSIF 269

// Token `` "`end'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kEND 265

// Token `` "`ensure'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kENSURE 264

// Token `` "`false'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kFALSE 291

// Token `` "`for'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kFOR 275

// Token `` "`if'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kIF 266

// Token `` "`if' modifier" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kIF_MOD 295

// Token `` "`in'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kIN 280

// Token `` "`module'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kMODULE 259

// Token `` "`next'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kNEXT 277

// Token `` "`nil'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kNIL 289

// Token `` "`not'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kNOT 294

// Token `` "`or'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kOR 293

// Token `` "`redo'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kREDO 278

// Token `` "`rescue'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kRESCUE 263

// Token `` "`rescue' modifier" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kRESCUE_MOD 299

// Token `` "`retry'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kRETRY 279

// Token `` "`return'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kRETURN 285

// Token `` "`self'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kSELF 288

// Token `` "`super'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kSUPER 287

// Token `` "`then'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kTHEN 268

// Token `` "`true'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kTRUE 290

// Token `` "`undef'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kUNDEF 261

// Token `` "`unless'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kUNLESS 267

// Token `` "`unless' modifier" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kUNLESS_MOD 296

// Token `` "`until'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kUNTIL 274

// Token `` "`until' modifier" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kUNTIL_MOD 298

// Token `` "`when'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kWHEN 272

// Token `` "`while'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kWHILE 273

// Token `` "`while' modifier" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kWHILE_MOD 297

// Token `` "`yield'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_kYIELD 286

// Token `` "`__ENCODING__'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_k__ENCODING__ 306

// Token `` "`__FILE__'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_k__FILE__ 305

// Token `` "`__LINE__'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_k__LINE__ 304

// Token `` "`BEGIN'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_klBEGIN 302

// Token `` "`END'" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_klEND 303

// Token `` "&" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tAMPER 364

// Token `` "& (tAMPER2)" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tAMPER2 386

// Token `` "&." ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tANDDOT 351

// Token `` "&&" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tANDOP 339

// Token `` "[]" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tAREF 347

// Token `` "[]=" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tASET 348

// Token `` "=>" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tASSOC 355

// Token `` "backslash" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tBACKSLASH 324

// Token `` "back reference" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tBACK_REF 320

// Token `` "`" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tBACK_REF2 389

// Token `` "!" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tBANG 402

// Token `` "(.." ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tBDOT2 345

// Token `` "(..." ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tBDOT3 346

// Token `` "^" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tCARET 390

// Token `` "char literal" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tCHAR 318

// Token `` "<=>" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tCMP 333

// Token `` tCOLON ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tCOLON 405

// Token `` "::" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tCOLON2 352

// Token `` ":: at EXPR_BEG" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tCOLON3 353

// Token `` "," ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tCOMMA 380

// Token `` "constant" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tCONSTANT 311

// Token `` "class variable" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tCVAR 312

// Token `` "/" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tDIVIDE 399

// Token `` tDOT ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tDOT 323

// Token `` ".." ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tDOT2 343

// Token `` "..." ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tDOT3 344

// Token `` "**arg" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tDSTAR 363

// Token `` tEH ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tEH 404

// Token `` "==" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tEQ 334

// Token `` "=" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tEQL 384

// Token `` "===" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tEQQ 335

// Token `` "method" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tFID 308

// Token `` "float literal" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tFLOAT 315

// Token `` ">=" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tGEQ 337

// Token `` ">" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tGT 387

// Token `` "global variable" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tGVAR 309

// Token `` "local variable or method" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tIDENTIFIER 307

// Token `` "imaginary literal" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tIMAGINARY 317

// Token `` "integer literal" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tINTEGER 314

// Token `` "instance variable" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tIVAR 310

// Token `` "label" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tLABEL 313

// Token `` tLABEL_END ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tLABEL_END 379

// Token `` "->" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tLAMBDA 365

// Token `` tLAMBEG ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tLAMBEG 378

// Token `` tLAST_TOKEN ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tLAST_TOKEN 407

// Token `` "{" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tLBRACE 360

// Token `` "{ arg" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tLBRACE_ARG 361

// Token `` "[" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tLBRACK 359

// Token `` "[ (tLBRACK2)" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tLBRACK2 383

// Token `` "{ (tLCURLY)" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tLCURLY 381

// Token `` "<=" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tLEQ 338

// Token `` tLOWEST ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tLOWEST 403

// Token `` "(" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tLPAREN 356

// Token `` "( (tLPAREN2)" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tLPAREN2 391

// Token `` "( arg" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tLPAREN_ARG 357

// Token `` "<<" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tLSHFT 349

// Token `` "<" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tLT 388

// Token `` "=~" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tMATCH 341

// Token `` "-" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tMINUS 397

// Token `` "!=" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tNEQ 336

// Token `` "\n" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tNL 395

// Token `` "!~" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tNMATCH 342

// Token `` "numbered reference" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tNTH_REF 319

// Token `` "operator-assignment" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tOP_ASGN 354

// Token `` "||" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tOROP 340

// Token `` "%" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tPERCENT 400

// Token `` "|" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tPIPE 385

// Token `` "+" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tPLUS 396

// Token `` "**" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tPOW 332

// Token `` "verbatim symbol list" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tQSYMBOLS_BEG 373

// Token `` "verbatim word list" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tQWORDS_BEG 371

// Token `` "rational literal" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tRATIONAL 316

// Token `` "]" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tRBRACK 392

// Token `` "}" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tRCURLY 382

// Token `` "regexp literal" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tREGEXP_BEG 369

// Token `` tREGEXP_END ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tREGEXP_END 322

// Token `` ")" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tRPAREN 358

// Token `` ">>" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tRSHFT 350

// Token `` ";" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tSEMI 393

// Token `` "escaped form feed" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tSLASH_F 327

// Token `` "escaped carriage return" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tSLASH_R 328

// Token `` "escaped horizontal tab" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tSLASH_T 326

// Token `` "escaped space" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tSP 325

// Token `` " " ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tSPACE 394

// Token `` "*" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tSTAR 362

// Token `` "* (tSTAR2)" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tSTAR2 398

// Token `` "string begin" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tSTRING_BEG 367

// Token `` "literal content" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tSTRING_CONTENT 321

// Token `` tSTRING_DBEG ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tSTRING_DBEG 376

// Token `` "tRCURLY" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tSTRING_DEND 375

// Token `` tSTRING_DVAR ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tSTRING_DVAR 377

// Token `` "string end" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tSTRING_END 374

// Token `` "symbol literal" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tSYMBEG 366

// Token `` "symbol list" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tSYMBOLS_BEG 372

// Token `` "~" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tTILDE 401

// Token `` "unary-" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tUMINUS 331

// Token `` tUMINUS_NUM ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tUMINUS_NUM 406

// Token `` "unary+" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tUPLUS 330

// Token `` "escaped vertical tab" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tVTAB 329

// Token `` "word list" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tWORDS_BEG 370

// Token `` "backtick literal" ``, to be returned by the scanner.
#define LIB_RUBY_PARSER_Lexer_tXSTRING_BEG 368

// Enum of all possible comment types
typedef enum LIB_RUBY_PARSER_CommentType {
  // Inline comment like
  //
  // ```text
  // # comment
  // ```
  COMMENT_TYPE_INLINE,
  // Document comment like
  //
  // ```text
  // =begin
  // comment
  // =end
  // ```
  COMMENT_TYPE_DOCUMENT,
  // Uknknown comment type,
  // most probably means that either `Loc` or given `Input` is invalid
  COMMENT_TYPE_UNKNOWN,
} LIB_RUBY_PARSER_CommentType;

// Error level of the diagnostic message
typedef enum LIB_RUBY_PARSER_ErrorLevel {
  // Warning level
  ERROR_LEVEL_WARNING,
  // Error level
  ERROR_LEVEL_ERROR,
} LIB_RUBY_PARSER_ErrorLevel;

// An enum of all magic comment kinds
typedef enum LIB_RUBY_PARSER_MagicCommentKind {
  // `# encoding: ... comment`
  MAGIC_COMMENT_KIND_ENCODING,
  // `# frozen_string_literal: true/false` comment
  MAGIC_COMMENT_KIND_FROZEN_STRING_LITERAL,
  // `# warn_ident: true/false` comment
  MAGIC_COMMENT_KIND_WARN_INDENT,
  // `# shareable_constant_value: ...` comment
  MAGIC_COMMENT_KIND_SHAREABLE_CONTSTANT_VALUE,
} LIB_RUBY_PARSER_MagicCommentKind;

// Enum of what token rewriter should do with a token.
typedef enum LIB_RUBY_PARSER_RewriteAction {
  // Means "drop the token", i.e. don't return it to a parser
  REWRITE_ACTION_DROP,
  // Means "keep the token", i.e. return it to a parser
  REWRITE_ACTION_KEEP,
} LIB_RUBY_PARSER_RewriteAction;

// C-compatible not nullable String container
typedef struct LIB_RUBY_PARSER_StringPtr {
  // Raw ponter
  uint8_t *ptr;
  // Length
  size_t len;
} LIB_RUBY_PARSER_StringPtr;

// A type of the debug level
typedef int8_t LIB_RUBY_PARSER_Type;

// C-compatible list
typedef struct LIB_RUBY_PARSER_ByteList {
  uint8_t *ptr;
  size_t len;
  size_t capacity;
} LIB_RUBY_PARSER_ByteList;

// An enum with all possible kinds of errors that can be returned
// from a decoder
typedef enum LIB_RUBY_PARSER_InputError_Tag {
  // Emitted when no custom decoder provided but input has custom encoding.
  //
  // You can return this error from your custom decoder if you don't support given encoding.
  INPUT_ERROR_UNSUPPORTED_ENCODING,
  // Generic error that can be emitted from a custom decoder
  INPUT_ERROR_DECODING_ERROR,
} LIB_RUBY_PARSER_InputError_Tag;

typedef struct LIB_RUBY_PARSER_InputError {
  LIB_RUBY_PARSER_InputError_Tag tag;
  union {
    struct {
      struct LIB_RUBY_PARSER_StringPtr unsupported_encoding;
    };
    struct {
      struct LIB_RUBY_PARSER_StringPtr decoding_error;
    };
  };
} LIB_RUBY_PARSER_InputError;

// Result that is returned from decoding function
typedef enum LIB_RUBY_PARSER_CustomDecoderResult_Tag {
  // Ok + decoded bytes
  CUSTOM_DECODER_RESULT_OK,
  // Err + reason
  CUSTOM_DECODER_RESULT_ERR,
} LIB_RUBY_PARSER_CustomDecoderResult_Tag;

typedef struct LIB_RUBY_PARSER_CustomDecoderResult {
  LIB_RUBY_PARSER_CustomDecoderResult_Tag tag;
  union {
    struct {
      struct LIB_RUBY_PARSER_ByteList ok;
    };
    struct {
      struct LIB_RUBY_PARSER_InputError err;
    };
  };
} LIB_RUBY_PARSER_CustomDecoderResult;

typedef struct LIB_RUBY_PARSER_CustomDecoderResult (*LIB_RUBY_PARSER_ForeignCustomDecoderFn)(struct LIB_RUBY_PARSER_StringPtr, struct LIB_RUBY_PARSER_ByteList);

// C-compatible custom decoder
typedef struct LIB_RUBY_PARSER_ForeignCustomDecoder {
  LIB_RUBY_PARSER_ForeignCustomDecoderFn f;
  bool dummy;
} LIB_RUBY_PARSER_ForeignCustomDecoder;

// Representation of a byte sequence
typedef struct LIB_RUBY_PARSER_Bytes {
  // Raw vector of bytes
  struct LIB_RUBY_PARSER_ByteList raw;
} LIB_RUBY_PARSER_Bytes;

//
typedef struct LIB_RUBY_PARSER_Loc {
  // Begin of the `Loc` range
  size_t begin;
  // End of the `Loc` range
  size_t end;
} LIB_RUBY_PARSER_Loc;

// State of the lexer
typedef struct LIB_RUBY_PARSER_LexState {
  int32_t value;
} LIB_RUBY_PARSER_LexState;

// A token that is emitted by a lexer and consumed by a parser
typedef struct LIB_RUBY_PARSER_Token {
  // Numeric representation of the token type,
  // e.g. 42 (for example) for tINTEGER
  int32_t token_type;
  // Value of the token,
  // e.g "42" for 42
  struct LIB_RUBY_PARSER_Bytes token_value;
  // Location of the token
  struct LIB_RUBY_PARSER_Loc loc;
  // Lex state **before** reading the token
  struct LIB_RUBY_PARSER_LexState lex_state_before;
  // Lex state **after** reading the token
  struct LIB_RUBY_PARSER_LexState lex_state_after;
} LIB_RUBY_PARSER_Token;

// C-compatible not-null pointer
typedef struct LIB_RUBY_PARSER_Ptr_Token {
  struct LIB_RUBY_PARSER_Token *ptr;
} LIB_RUBY_PARSER_Ptr_Token;

// Enum of what token rewriter should do with the state of the lexer
typedef enum LIB_RUBY_PARSER_LexStateAction_Tag {
  // Means "set the state to X"
  LEX_STATE_ACTION_SET,
  // Means "keep the state unchanged"
  LEX_STATE_ACTION_KEEP,
} LIB_RUBY_PARSER_LexStateAction_Tag;

typedef struct LIB_RUBY_PARSER_LexStateAction {
  LIB_RUBY_PARSER_LexStateAction_Tag tag;
  union {
    struct {
      int32_t set;
    };
  };
} LIB_RUBY_PARSER_LexStateAction;

// Output of the token rewriter
typedef struct LIB_RUBY_PARSER_TokenRewriterResult {
  // Rewritten token. Can be input token if no rewriting expected
  struct LIB_RUBY_PARSER_Ptr_Token rewritten_token;
  // Action to be applied on a token (keep or drop)
  enum LIB_RUBY_PARSER_RewriteAction token_action;
  // Action to be applied on lexer's state (keep as is or change)
  struct LIB_RUBY_PARSER_LexStateAction lex_state_action;
} LIB_RUBY_PARSER_TokenRewriterResult;

// C-compatible shared list
typedef struct LIB_RUBY_PARSER_SharedByteList {
  uint8_t *ptr;
  size_t len;
} LIB_RUBY_PARSER_SharedByteList;

typedef struct LIB_RUBY_PARSER_TokenRewriterResult (*LIB_RUBY_PARSER_ForeignTokenRewriterFn)(struct LIB_RUBY_PARSER_Ptr_Token, struct LIB_RUBY_PARSER_SharedByteList);

// C-compatible token rewriter struct
typedef struct LIB_RUBY_PARSER_ForeignTokenRewriter {
  LIB_RUBY_PARSER_ForeignTokenRewriterFn f;
  bool dummy;
} LIB_RUBY_PARSER_ForeignTokenRewriter;

// Foreign parser options, can be casted to Rust ParserOptions
typedef struct LIB_RUBY_PARSER_ParserOptions {
  // Equivalent of ParserOptions.buffer_name
  struct LIB_RUBY_PARSER_StringPtr buffer_name;
  // Equivalent of ParserOptions.debug
  LIB_RUBY_PARSER_Type debug;
  // Equivalent of ParserOptions.decoder
  struct LIB_RUBY_PARSER_ForeignCustomDecoder decoder;
  // Equivalent of ParserOptions.token_rewriter
  struct LIB_RUBY_PARSER_ForeignTokenRewriter token_rewriter;
  // Equivalent of ParserOptions.record_tokens
  bool record_tokens;
} LIB_RUBY_PARSER_ParserOptions;

// Enum of all possible diagnostic message (both warnings and errors)
typedef enum LIB_RUBY_PARSER_DiagnosticMessage_Tag {
  // Emitted for code
  // ```text
  // 1.2.3
  // ```
  //
  DIAGNOSTIC_MESSAGE_FRACTION_AFTER_NUMERIC,
  // Emitted for code like
  // ```text
  // foo.2
  // ```
  //
  DIAGNOSTIC_MESSAGE_NO_DIGITS_AFTER_DOT,
  // Emitted for code like
  // ```text
  // %k[foo]
  // ```
  //
  DIAGNOSTIC_MESSAGE_UNKNOWN_TYPE_OF_PERCENT_STRING,
  // Emitted for code like
  // ```text
  // 0b
  // ```
  //
  DIAGNOSTIC_MESSAGE_NUMERIC_LITERAL_WITHOUT_DIGITS,
  // Emitted for code like
  // ```text
  // %w[foo bar
  // ```
  //
  DIAGNOSTIC_MESSAGE_UNTERMINATED_LIST,
  // Emitted for code like
  // ```text
  // /foo
  // ```
  //
  DIAGNOSTIC_MESSAGE_UNTERMINATED_REGEXP,
  // Emitted for code like
  // ```text
  // "foo
  // ```
  //
  DIAGNOSTIC_MESSAGE_UNTERMINATED_STRING,
  // Emitted for code like
  // ```text
  // %s
  // //    ^ EOF, not \n
  // ```
  //
  DIAGNOSTIC_MESSAGE_UNTERMINATED_QUOTED_STRING,
  // Emitted for code like
  // ```text
  // "\ufoo"
  // ```
  //
  DIAGNOSTIC_MESSAGE_INVALID_UNICODE_ESCAPE,
  // Emitted for code like
  // ```text
  // "\u{999999}"
  // ```
  //
  DIAGNOSTIC_MESSAGE_TOO_LARGE_UNICODE_CODEPOINT,
  // Emitted for code like
  // ```text
  // "\u{d800}"
  // ```
  //
  DIAGNOSTIC_MESSAGE_INVALID_UNICODE_CODEPOINT,
  // Emitted for code like
  // ```text
  // ?\u{41 42}
  // ```
  //
  DIAGNOSTIC_MESSAGE_MULTIPLE_CODEPOINT_AT_SINGLE_CHAR,
  // Emitted for code like
  // ```text
  // "\M-"
  // ```
  //
  DIAGNOSTIC_MESSAGE_INVALID_ESCAPE_CHARACTER,
  // Emitted for code like
  // ```text
  // "\xZZ"
  // ```
  //
  DIAGNOSTIC_MESSAGE_INVALID_HEX_ESCAPE,
  // Emitted for code like
  // ```text
  // <<-HERE
  // ```
  //
  DIAGNOSTIC_MESSAGE_UNTERMINATED_HEREDOC,
  // Emitted for code like
  // ```text
  // <<-"HERE
  // ```
  //
  DIAGNOSTIC_MESSAGE_UNTERMINATED_HEREDOC_ID,
  // Emitted for code like
  // ```text
  // eval("foo \r = 42")
  // ```
  //
  DIAGNOSTIC_MESSAGE_SLASH_R_AT_MIDDLE_OF_LINE,
  // Emitted for code like (only in $VERBOSE mode)
  // ```text
  // foo **arg
  // ```
  //
  DIAGNOSTIC_MESSAGE_D_STAR_INTERPRETED_AS_ARG_PREFIX,
  // Emitted for code like (only in $VERBOSE mode)
  // ```text
  // foo *arg
  // ```
  //
  DIAGNOSTIC_MESSAGE_STAR_INTERPRETED_AS_ARG_PREFIX,
  // Emitted for code like (only in $VERBOSE mode)
  // ```text
  // foo &arg
  // ```
  //
  DIAGNOSTIC_MESSAGE_AMPERSAND_INTERPRETED_AS_ARG_PREFIX,
  // Emitted for code like
  // ```text
  // range = 1...
  // ```
  //
  DIAGNOSTIC_MESSAGE_TRIPLE_DOT_AT_EOL,
  // Emitted for code like (only in $VERBOSE mode)
  // ```text
  // def m (a, b, c); end
  // ```
  //
  DIAGNOSTIC_MESSAGE_PARENTHESES_ITERPRETED_AS_ARGLIST,
  // Emitted for code like (only in $VERBOSE mode)
  // ```text
  // m +foo
  // ```
  //
  DIAGNOSTIC_MESSAGE_AMBIGUOUS_FIRST_ARGUMENT,
  // Emitted for code like (only in $VERBOSE mode)
  // ```text
  // 1 *2
  // ```
  //
  DIAGNOSTIC_MESSAGE_AMBIGUOUS_OPERATOR,
  // Emitted for code like
  // ```text
  // "\M- "
  // ```
  //
  DIAGNOSTIC_MESSAGE_INVALID_CHARACTER_SYNTAX,
  // Emitted for code like
  // ```text
  // 09
  // ```
  //
  DIAGNOSTIC_MESSAGE_INVALID_OCTAL_DIGIT,
  // Emitted for code like
  // ```text
  // 0_a
  // ```
  //
  DIAGNOSTIC_MESSAGE_TRAILING_CHAR_IN_NUMBER,
  // Emitted for code like
  // ```text
  // =begin
  // ```
  //
  DIAGNOSTIC_MESSAGE_EMBEDDED_DOCUMENT_MEETS_EOF,
  // Emitted for code like
  // ```text
  // eval("\x01foo")
  // ```
  //
  DIAGNOSTIC_MESSAGE_INVALID_CHAR,
  // It is unknown how to trigger this error.
  // Code that triggers it in MRI can be dead.
  //
  DIAGNOSTIC_MESSAGE_INCOMPLETE_CHARACTER_SYNTAX,
  // Emitted for code like
  // ```text
  // $
  // ```
  //
  DIAGNOSTIC_MESSAGE_GVAR_WITHOUT_ID,
  // Emitted for code like
  // ```text
  // $@
  // ```
  //
  DIAGNOSTIC_MESSAGE_INVALID_GVAR_NAME,
  // Emitted for code like
  // ```text
  // @
  // ```
  //
  DIAGNOSTIC_MESSAGE_IVAR_WITHOUT_ID,
  // Emitted for code like
  // ```text
  // @1
  // ```
  //
  DIAGNOSTIC_MESSAGE_INVALID_IVAR_NAME,
  // Emitted for code like
  // ```text
  // @@
  // ```
  //
  DIAGNOSTIC_MESSAGE_CVAR_WITHOUT_ID,
  // Emitted for code like
  // ```text
  // @@1
  // ```
  //
  DIAGNOSTIC_MESSAGE_INVALID_CVAR_NAME,
  // Emitted for code like
  // ```text
  // /re/foo
  // ```
  //
  DIAGNOSTIC_MESSAGE_UNKNOWN_REGEX_OPTIONS,
  // Emitted for code like
  // ```text
  // "\u{1234"
  // ```
  //
  DIAGNOSTIC_MESSAGE_UNTERMINATED_UNICODE_ESCAPE,
  // Emitted for code like
  // ```text
  // # encoding: foo
  // ```
  //
  DIAGNOSTIC_MESSAGE_ENCODING_ERROR,
  // Emitter for code like
  // ```text
  // eval("\xFF = 42")
  // ```
  //
  DIAGNOSTIC_MESSAGE_INVALID_MULTIBYTE_CHAR,
  // Emitted for code like
  // ```text
  // a ?AA : 2
  // ```
  //
  DIAGNOSTIC_MESSAGE_AMBIGUOUS_TERNARY_OPERATOR,
  // Emitted for code like
  // ```text
  // m /foo/
  // ```
  //
  DIAGNOSTIC_MESSAGE_AMBIGUOUS_REGEXP,
  // Emitted for code like
  // ```text
  // begin; else; end
  // ```
  //
  DIAGNOSTIC_MESSAGE_ELSE_WITHOUT_RESCUE,
  // Emitted for code like
  // ```text
  // def f; BEGIN{}; end
  // ```
  //
  DIAGNOSTIC_MESSAGE_BEGIN_NOT_AT_TOP_LEVEL,
  // Emitted for code like
  // ```text
  // alias $a $1
  // ```
  //
  DIAGNOSTIC_MESSAGE_ALIAS_NTH_REF,
  // Emitted for code like
  // ```text
  // *a&.x = 0
  // ```
  //
  DIAGNOSTIC_MESSAGE_CSEND_INSIDE_MASGN,
  // Emitted for code like
  // ```text
  // module foo; end
  // ```
  //
  DIAGNOSTIC_MESSAGE_CLASS_OR_MODULE_NAME_MUST_BE_CONSTANT,
  // Emitted for code like
  // ```text
  // def foo=() = 42
  // ```
  //
  DIAGNOSTIC_MESSAGE_ENDLESS_SETTER_DEFINITION,
  // Emitted for any code that produces invalid sequence of tokens
  //
  DIAGNOSTIC_MESSAGE_UNEXPECTED_TOKEN,
  // Emitted for code like
  // ```text
  // def a; class Foo; end; end
  // ```
  //
  DIAGNOSTIC_MESSAGE_CLASS_DEFINITION_IN_METHOD_BODY,
  // Emitted for code like
  // ```text
  // def a; module Foo; end; end
  // ```
  //
  DIAGNOSTIC_MESSAGE_MODULE_DEFINITION_IN_METHOD_BODY,
  // Emitted for code like
  // ```text
  // class A; return; end
  // ```
  //
  DIAGNOSTIC_MESSAGE_INVALID_RETURN_IN_CLASS_OR_MODULE_BODY,
  // Emitted for code like
  // ```text
  // def foo(Abc); end
  // ```
  //
  DIAGNOSTIC_MESSAGE_CONST_ARGUMENT,
  // Emitted for code like
  // ```text
  // def foo(@abc); end
  // ```
  //
  DIAGNOSTIC_MESSAGE_IVAR_ARGUMENT,
  // Emitted for code like
  // ```text
  // def foo($abc); end
  // ```
  //
  DIAGNOSTIC_MESSAGE_GVAR_ARGUMENT,
  // Emitted for code like
  // ```text
  // def foo(@@abc); end
  // ```
  //
  DIAGNOSTIC_MESSAGE_CVAR_ARGUMENT,
  // Emitted for code like
  // ```text
  // case 0; in ^a; true; end
  // ```
  //
  DIAGNOSTIC_MESSAGE_NO_SUCH_LOCAL_VARIABLE,
  // Emitted for code like
  // ```text
  // m { |a| _1 }
  // ```
  //
  DIAGNOSTIC_MESSAGE_ORDINARY_PARAM_DEFINED,
  // Emitted for code like
  // ```text
  // foo { _1; bar { _2 }; }
  // ```
  //
  DIAGNOSTIC_MESSAGE_NUMPARAM_USED,
  // Emitted for code like (only in $VERBOSE mode)
  // ```text
  // if
  // 42
  // end
  // ```
  //
  DIAGNOSTIC_MESSAGE_TOK_AT_EOL_WITHOUT_EXPRESSION,
  // Emitted for code like
  // ```text
  // def m; END {}; end
  // ```
  //
  DIAGNOSTIC_MESSAGE_END_IN_METHOD,
  // Emitted for code like (only in $VERBOSE mode)
  // ```text
  // a < b < c
  // ```
  //
  DIAGNOSTIC_MESSAGE_COMPARISON_AFTER_COMPARISON,
  // Emitted for code like
  // ```text
  // def m(foo = foo) end
  // ```
  //
  DIAGNOSTIC_MESSAGE_CIRCULAR_ARGUMENT_REFERENCE,
  // Emitted for code like
  // ```text
  // def m; FOO = 1; end
  // ```
  //
  DIAGNOSTIC_MESSAGE_DYNAMIC_CONSTANT_ASSIGNMENT,
  // Emitted for code like
  // ```text
  // self = foo
  // ```
  //
  DIAGNOSTIC_MESSAGE_CANT_ASSIGN_TO_SELF,
  // Emitted for code like
  // ```text
  // nil = foo
  // ```
  //
  DIAGNOSTIC_MESSAGE_CANT_ASSIGN_TO_NIL,
  // Emitted for code like
  // ```text
  // true = foo
  // ```
  //
  DIAGNOSTIC_MESSAGE_CANT_ASSIGN_TO_TRUE,
  // Emitted for code like
  // ```text
  // false = foo
  // ```
  //
  DIAGNOSTIC_MESSAGE_CANT_ASSIGN_TO_FALSE,
  // Emitted for code like
  // ```text
  // __FILE__ = foo
  // ```
  //
  DIAGNOSTIC_MESSAGE_CANT_ASSIGN_TO_FILE,
  // Emitted for code like
  // ```text
  // __LINE__ = foo
  // ```
  //
  DIAGNOSTIC_MESSAGE_CANT_ASSIGN_TO_LINE,
  // Emitted for code like
  // ```text
  // __ENCODING__ = foo
  // ```
  //
  DIAGNOSTIC_MESSAGE_CANT_ASSIGN_TO_ENCODING,
  // Emitted for code like
  // ```text
  // proc {_1; _1 = nil}
  // ```
  //
  DIAGNOSTIC_MESSAGE_CANT_ASSIGN_TO_NUMPARAM,
  // Emitted for code like
  // ```text
  // $1 = foo
  // ```
  //
  DIAGNOSTIC_MESSAGE_CANT_SET_VARIABLE,
  // Emitted for code like
  // ```text
  // yield(&foo)
  // ```
  //
  DIAGNOSTIC_MESSAGE_BLOCK_GIVEN_TO_YIELD,
  // Emitted for code like
  // ```text
  // fun(&bar) do end
  // ```
  //
  DIAGNOSTIC_MESSAGE_BLOCK_AND_BLOCK_ARG_GIVEN,
  // Emitted for code like
  // ```text
  // case a; in "#{a}": 1; end
  // ```
  //
  DIAGNOSTIC_MESSAGE_SYMBOL_LITERAL_WITH_INTERPOLATION,
  // Emitted for code like
  // ```text
  // _1 = 1
  // ```
  //
  DIAGNOSTIC_MESSAGE_RESERVED_FOR_NUMPARAM,
  // Emitted for code like
  // ```text
  // case a; in a?:; end
  // ```
  //
  DIAGNOSTIC_MESSAGE_KEY_MUST_BE_VALID_AS_LOCAL_VARIABLE,
  // Emitted for code like
  // ```text
  // case 0; in a, a; end
  // ```
  //
  DIAGNOSTIC_MESSAGE_DUPLICATE_VARIABLE_NAME,
  // Emitted for code like
  // ```text
  // case 0; in a: 1, a: 2; end
  // ```
  //
  DIAGNOSTIC_MESSAGE_DUPLICATE_KEY_NAME,
  // Emitted for code like
  // ```text
  // def (1).foo; end
  // ```
  //
  DIAGNOSTIC_MESSAGE_SINGLETON_LITERAL,
  // Emitted for code like (only in $VERBOSE mode)
  // ```text
  // $100
  // ```
  //
  DIAGNOSTIC_MESSAGE_NTH_REF_IS_TOO_BIG,
  // Emitted for code like
  // ```text
  // def foo(aa, aa); end
  // ```
  //
  DIAGNOSTIC_MESSAGE_DUPLICATED_ARGUMENT_NAME,
  // Emitted for code like
  // ```text
  // /[/
  // ```
  //
  DIAGNOSTIC_MESSAGE_REGEX_ERROR,
  // Emitted for code like
  // ```text
  // %I"x .\xc3."
  // ```
  //
  DIAGNOSTIC_MESSAGE_INVALID_SYMBOL,
  // Emitted for code like
  // ```text
  // a = return
  // ```
  //
  DIAGNOSTIC_MESSAGE_VOID_VALUE_EXPRESSION,
} LIB_RUBY_PARSER_DiagnosticMessage_Tag;

typedef struct LIB_RUBY_PARSER_UnterminatedHeredoc_Body {
  // Heredoc identifier
  struct LIB_RUBY_PARSER_StringPtr heredoc_id;
} LIB_RUBY_PARSER_UnterminatedHeredoc_Body;

typedef struct LIB_RUBY_PARSER_AmbiguousFirstArgument_Body {
  // Operator that is ambiguous
  uint8_t operator_;
} LIB_RUBY_PARSER_AmbiguousFirstArgument_Body;

typedef struct LIB_RUBY_PARSER_AmbiguousOperator_Body {
  // Operator that is ambiguous
  struct LIB_RUBY_PARSER_StringPtr operator_;
  // Interpretation of this operator
  struct LIB_RUBY_PARSER_StringPtr interpreted_as;
} LIB_RUBY_PARSER_AmbiguousOperator_Body;

typedef struct LIB_RUBY_PARSER_InvalidCharacterSyntax_Body {
  // Valid syntax sugestions
  struct LIB_RUBY_PARSER_StringPtr suggestion;
} LIB_RUBY_PARSER_InvalidCharacterSyntax_Body;

typedef struct LIB_RUBY_PARSER_TrailingCharInNumber_Body {
  // Invalid trailing char
  uint8_t c;
} LIB_RUBY_PARSER_TrailingCharInNumber_Body;

typedef struct LIB_RUBY_PARSER_InvalidChar_Body {
  // char
  uint8_t c;
} LIB_RUBY_PARSER_InvalidChar_Body;

typedef struct LIB_RUBY_PARSER_InvalidGvarName_Body {
  // char after `$`
  uint8_t c;
} LIB_RUBY_PARSER_InvalidGvarName_Body;

typedef struct LIB_RUBY_PARSER_InvalidIvarName_Body {
  // char after `@`
  uint8_t c;
} LIB_RUBY_PARSER_InvalidIvarName_Body;

typedef struct LIB_RUBY_PARSER_InvalidCvarName_Body {
  // char after `@@`
  uint8_t c;
} LIB_RUBY_PARSER_InvalidCvarName_Body;

typedef struct LIB_RUBY_PARSER_UnknownRegexOptions_Body {
  // Concatenated unknown options
  struct LIB_RUBY_PARSER_StringPtr options;
} LIB_RUBY_PARSER_UnknownRegexOptions_Body;

typedef struct LIB_RUBY_PARSER_EncodingError_Body {
  // Error from decoder
  struct LIB_RUBY_PARSER_StringPtr error;
} LIB_RUBY_PARSER_EncodingError_Body;

typedef struct LIB_RUBY_PARSER_AmbiguousTernaryOperator_Body {
  // Source of the condition expression
  struct LIB_RUBY_PARSER_StringPtr condition;
} LIB_RUBY_PARSER_AmbiguousTernaryOperator_Body;

typedef struct LIB_RUBY_PARSER_UnexpectedToken_Body {
  // Name of the token
  struct LIB_RUBY_PARSER_StringPtr token_name;
} LIB_RUBY_PARSER_UnexpectedToken_Body;

typedef struct LIB_RUBY_PARSER_NoSuchLocalVariable_Body {
  // Variable name
  struct LIB_RUBY_PARSER_StringPtr var_name;
} LIB_RUBY_PARSER_NoSuchLocalVariable_Body;

typedef struct LIB_RUBY_PARSER_TokAtEolWithoutExpression_Body {
  // Name of the token
  struct LIB_RUBY_PARSER_StringPtr token_name;
} LIB_RUBY_PARSER_TokAtEolWithoutExpression_Body;

typedef struct LIB_RUBY_PARSER_ComparisonAfterComparison_Body {
  // Source of the first comparison
  struct LIB_RUBY_PARSER_StringPtr comparison;
} LIB_RUBY_PARSER_ComparisonAfterComparison_Body;

typedef struct LIB_RUBY_PARSER_CircularArgumentReference_Body {
  // Name of the argument
  struct LIB_RUBY_PARSER_StringPtr arg_name;
} LIB_RUBY_PARSER_CircularArgumentReference_Body;

typedef struct LIB_RUBY_PARSER_CantAssignToNumparam_Body {
  // Source of the numbered parameter
  struct LIB_RUBY_PARSER_StringPtr numparam;
} LIB_RUBY_PARSER_CantAssignToNumparam_Body;

typedef struct LIB_RUBY_PARSER_CantSetVariable_Body {
  // Source of the read-only variable that is assigned
  struct LIB_RUBY_PARSER_StringPtr var_name;
} LIB_RUBY_PARSER_CantSetVariable_Body;

typedef struct LIB_RUBY_PARSER_ReservedForNumparam_Body {
  // Numbered parameter that is treated as a local variable
  struct LIB_RUBY_PARSER_StringPtr numparam;
} LIB_RUBY_PARSER_ReservedForNumparam_Body;

typedef struct LIB_RUBY_PARSER_NthRefIsTooBig_Body {
  // Source of the nth_ref that is techincally a regular global variable
  struct LIB_RUBY_PARSER_StringPtr nth_ref;
} LIB_RUBY_PARSER_NthRefIsTooBig_Body;

typedef struct LIB_RUBY_PARSER_RegexError_Body {
  // Error from Onigurama engine
  struct LIB_RUBY_PARSER_StringPtr error;
} LIB_RUBY_PARSER_RegexError_Body;

typedef struct LIB_RUBY_PARSER_InvalidSymbol_Body {
  // Source of the symbol
  struct LIB_RUBY_PARSER_StringPtr symbol;
} LIB_RUBY_PARSER_InvalidSymbol_Body;

typedef struct LIB_RUBY_PARSER_DiagnosticMessage {
  LIB_RUBY_PARSER_DiagnosticMessage_Tag tag;
  union {
    LIB_RUBY_PARSER_UnterminatedHeredoc_Body UNTERMINATED_HEREDOC;
    LIB_RUBY_PARSER_AmbiguousFirstArgument_Body AMBIGUOUS_FIRST_ARGUMENT;
    LIB_RUBY_PARSER_AmbiguousOperator_Body AMBIGUOUS_OPERATOR;
    LIB_RUBY_PARSER_InvalidCharacterSyntax_Body INVALID_CHARACTER_SYNTAX;
    LIB_RUBY_PARSER_TrailingCharInNumber_Body TRAILING_CHAR_IN_NUMBER;
    LIB_RUBY_PARSER_InvalidChar_Body INVALID_CHAR;
    LIB_RUBY_PARSER_InvalidGvarName_Body INVALID_GVAR_NAME;
    LIB_RUBY_PARSER_InvalidIvarName_Body INVALID_IVAR_NAME;
    LIB_RUBY_PARSER_InvalidCvarName_Body INVALID_CVAR_NAME;
    LIB_RUBY_PARSER_UnknownRegexOptions_Body UNKNOWN_REGEX_OPTIONS;
    LIB_RUBY_PARSER_EncodingError_Body ENCODING_ERROR;
    LIB_RUBY_PARSER_AmbiguousTernaryOperator_Body AMBIGUOUS_TERNARY_OPERATOR;
    LIB_RUBY_PARSER_UnexpectedToken_Body UNEXPECTED_TOKEN;
    LIB_RUBY_PARSER_NoSuchLocalVariable_Body NO_SUCH_LOCAL_VARIABLE;
    LIB_RUBY_PARSER_TokAtEolWithoutExpression_Body TOK_AT_EOL_WITHOUT_EXPRESSION;
    LIB_RUBY_PARSER_ComparisonAfterComparison_Body COMPARISON_AFTER_COMPARISON;
    LIB_RUBY_PARSER_CircularArgumentReference_Body CIRCULAR_ARGUMENT_REFERENCE;
    LIB_RUBY_PARSER_CantAssignToNumparam_Body CANT_ASSIGN_TO_NUMPARAM;
    LIB_RUBY_PARSER_CantSetVariable_Body CANT_SET_VARIABLE;
    LIB_RUBY_PARSER_ReservedForNumparam_Body RESERVED_FOR_NUMPARAM;
    LIB_RUBY_PARSER_NthRefIsTooBig_Body NTH_REF_IS_TOO_BIG;
    LIB_RUBY_PARSER_RegexError_Body REGEX_ERROR;
    LIB_RUBY_PARSER_InvalidSymbol_Body INVALID_SYMBOL;
  };
} LIB_RUBY_PARSER_DiagnosticMessage;

// Diagnostic message that comes from the parser when there's an error or warning
typedef struct LIB_RUBY_PARSER_Diagnostic {
  // Level of the diagnostic (error or warnings)
  enum LIB_RUBY_PARSER_ErrorLevel level;
  // Message of the diagnostic
  struct LIB_RUBY_PARSER_DiagnosticMessage message;
  // Location of the diagnostic
  struct LIB_RUBY_PARSER_Loc loc;
} LIB_RUBY_PARSER_Diagnostic;

// C-compatible list
typedef struct LIB_RUBY_PARSER_TokenList {
  struct LIB_RUBY_PARSER_Token *ptr;
  size_t len;
  size_t capacity;
} LIB_RUBY_PARSER_TokenList;

// C-compatible list
typedef struct LIB_RUBY_PARSER_DiagnosticList {
  struct LIB_RUBY_PARSER_Diagnostic *ptr;
  size_t len;
  size_t capacity;
} LIB_RUBY_PARSER_DiagnosticList;

// A struct that represents a comment in Ruby
typedef struct LIB_RUBY_PARSER_Comment {
  // Location of the comment (starts with `#` and ends with the last char)
  struct LIB_RUBY_PARSER_Loc location;
  // Kind of the comment
  enum LIB_RUBY_PARSER_CommentType kind;
} LIB_RUBY_PARSER_Comment;

// C-compatible list
typedef struct LIB_RUBY_PARSER_CommentList {
  struct LIB_RUBY_PARSER_Comment *ptr;
  size_t len;
  size_t capacity;
} LIB_RUBY_PARSER_CommentList;

// Representation of a magic comment in Ruby
typedef struct LIB_RUBY_PARSER_MagicComment {
  // Kind of a magic comment
  enum LIB_RUBY_PARSER_MagicCommentKind kind;
  // Location of the "key":
  //
  // ```text
  // # encoding: utf-8
  //   ~~~~~~~~
  // ```
  struct LIB_RUBY_PARSER_Loc key_l;
  // Location of the "value":
  //
  // ```text
  // # encoding: utf-8
  //             ~~~~~
  // ```
  struct LIB_RUBY_PARSER_Loc value_l;
} LIB_RUBY_PARSER_MagicComment;

// C-compatible list
typedef struct LIB_RUBY_PARSER_MagicCommentList {
  struct LIB_RUBY_PARSER_MagicComment *ptr;
  size_t len;
  size_t capacity;
} LIB_RUBY_PARSER_MagicCommentList;

typedef struct LIB_RUBY_PARSER_SourceLine {
  size_t start;
  size_t end;
  bool ends_with_eof;
} LIB_RUBY_PARSER_SourceLine;

// C-compatible list
typedef struct LIB_RUBY_PARSER_SourceLineList {
  struct LIB_RUBY_PARSER_SourceLine *ptr;
  size_t len;
  size_t capacity;
} LIB_RUBY_PARSER_SourceLineList;

// Decoded input
typedef struct LIB_RUBY_PARSER_DecodedInput {
  // Name of the input
  struct LIB_RUBY_PARSER_StringPtr name;
  // Lines list
  struct LIB_RUBY_PARSER_SourceLineList lines;
  // Decoded bytes
  struct LIB_RUBY_PARSER_ByteList bytes;
} LIB_RUBY_PARSER_DecodedInput;

// Combination of all data that `Parser` can give you
typedef struct LIB_RUBY_PARSER_ParserResult {
  // Abstract Syntax Tree that was constructed from you code.
  // Contains `None` if the code gives no AST nodes
  LIB_RUBY_PARSER_MaybePtr_Node ast;
  // List of tokens returned by a Lexer and consumed by a Parser.
  // Empty unless ParserOptions::record_tokens is set to true.
  struct LIB_RUBY_PARSER_TokenList tokens;
  // List of all diagnostics (errors and warings) that have been
  // recorded during lexing and parsing
  struct LIB_RUBY_PARSER_DiagnosticList diagnostics;
  // List of comments extracted from the source code.
  struct LIB_RUBY_PARSER_CommentList comments;
  // List of magic comments extracted from the source code.
  struct LIB_RUBY_PARSER_MagicCommentList magic_comments;
  // Input that was used for parsing.
  //
  // Note: this input is not necessary the same byte array that
  // you passed to Parser::parse. If encoding of the input is
  // not `UTF-8` or `ASCII-8BIT/BINARY` Parser invokes `decoder`
  // that usually produces a different sequence of bytes.
  //
  // Pass **this** data to `Loc::source`, otherwise you'll get
  // incorrect source ranges.
  struct LIB_RUBY_PARSER_DecodedInput input;
} LIB_RUBY_PARSER_ParserResult;

// C-compatible Option<Loc>
typedef enum LIB_RUBY_PARSER_MaybeLoc_Tag {
  // Equivalent of Option::Some
  MAYBE_LOC_SOME,
  // Equivalent of Option::None
  MAYBE_LOC_NONE,
} LIB_RUBY_PARSER_MaybeLoc_Tag;

typedef struct LIB_RUBY_PARSER_MaybeLoc {
  LIB_RUBY_PARSER_MaybeLoc_Tag tag;
  union {
    struct {
      struct LIB_RUBY_PARSER_Loc some;
    };
  };
} LIB_RUBY_PARSER_MaybeLoc;

// Representation of the value of the string literal
//
// In Ruby string literals don't have to be valid in their encoding.
// Because of that we don't even try to convert them into string.
// Instead, they are emitted as byte arrays that (if you want)
// can be converted to a string.
typedef struct LIB_RUBY_PARSER_StringValue {
  // Byte array, can be converted to a string
  struct LIB_RUBY_PARSER_Bytes bytes;
} LIB_RUBY_PARSER_StringValue;

// Represents `alias to from` statement.
//
typedef struct LIB_RUBY_PARSER_Alias {
  // Target of the `alias`.
  //
  // `Sym("foo")` node for `alias :foo :bar`
  //
  LIB_RUBY_PARSER_Ptr_Node to;
  // Source of the `alias`.
  //
  // `Sym("bar")` node for `alias :foo :bar`
  //
  LIB_RUBY_PARSER_Ptr_Node from;
  // Location of the `alias` keyword
  //
  // ```text
  // alias foo bar
  // ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the full expression
  //
  // ```text
  // alias foo bar
  // ~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Alias;

// Represents `a &&= 1` statement.
//
typedef struct LIB_RUBY_PARSER_AndAsgn {
  // Receiver of the `&&=` operation.
  //
  // `Lvasgn("a")` node for `a &&= 1`
  //
  LIB_RUBY_PARSER_Ptr_Node recv;
  // Right hand statement of assignment
  //
  // `Int("1")` node for `a &&= 1`
  //
  LIB_RUBY_PARSER_Ptr_Node value;
  // Location of the `&&=` operator
  //
  // ```text
  // a &&= 1
  //   ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the full expression
  //
  // ```text
  // a &&= 1
  // ~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_AndAsgn;

// Represents `foo && bar` (or `foo and bar`) statement.
//
typedef struct LIB_RUBY_PARSER_And {
  // Left hand statament of the `&&` operation.
  //
  // `Lvar("foo")` node for `foo && bar`
  //
  LIB_RUBY_PARSER_Ptr_Node lhs;
  // Right hand statement of the `&&` operation.
  //
  // `Lvar("bar")` node for `foo && bar`
  //
  LIB_RUBY_PARSER_Ptr_Node rhs;
  // Location of the `&&` (or `and`) operator
  //
  // ```text
  // a && b
  //   ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the full expression
  //
  // ```text
  // a && b
  // ~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_And;

// Represents a positional required block/method argument.
//
// `a` in `def m(a); end` or `proc { |a| }`
//
typedef struct LIB_RUBY_PARSER_Arg {
  // Name of the argument
  //
  struct LIB_RUBY_PARSER_StringPtr name;
  // Location of the full expression
  //
  // ```text
  // def m(argument); end
  //       ~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Arg;

// C-compatible list
typedef struct LIB_RUBY_PARSER_NodeList {
  struct LIB_RUBY_PARSER_Node *ptr;
  size_t len;
  size_t capacity;
} LIB_RUBY_PARSER_NodeList;

// Represents an arguments list
//
// `Args(vec![Arg("a"), Optarg("b", Int("1"))])` in `def m(a, b = 1); end`
//
typedef struct LIB_RUBY_PARSER_Args {
  // List of arguments
  //
  struct LIB_RUBY_PARSER_NodeList args;
  // Location of the full expression
  //
  // ```text
  // def m(a, b = 1, c:, &blk); end
  //      ~~~~~~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
  // Location of the open parenthesis
  //
  // ```text
  // def m(a, b = 1, c:, &blk); end
  //      ~
  // ```
  //
  // `None` for code like `def m; end` or `def m arg; end`
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of the closing parenthesis
  //
  // ```text
  // def m(a, b = 1, c:, &blk); end
  //                         ~
  // ```
  //
  // `None` for code like `def m; end` or `def m arg; end`
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
} LIB_RUBY_PARSER_Args;

// Represents an array literal
//
typedef struct LIB_RUBY_PARSER_Array {
  // A list of elements
  //
  struct LIB_RUBY_PARSER_NodeList elements;
  // Location of the open bracket
  //
  // ```text
  // [1, 2, 3]
  // ~
  // ```
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of the closing bracket
  //
  // ```text
  // [1, 2, 3]
  //         ~
  // ```
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the full expression
  //
  // ```text
  // [1, 2, 3]
  // ~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Array;

// Represents an array pattern used in pattern matching
//
typedef struct LIB_RUBY_PARSER_ArrayPattern {
  // A list of elements
  //
  struct LIB_RUBY_PARSER_NodeList elements;
  // Location of the open bracket
  //
  // ```text
  // [1, ^a, 3 => foo]
  // ~
  // ```
  //
  // `None` for pattern like `1, 2` without brackets
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of the closing bracket
  //
  // ```text
  // [1, ^a, 3 => foo]
  //                 ~
  // ```
  //
  // `None` for pattern like `1, 2` without brackets
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the full expression
  //
  // ```text
  // [1, ^a, 3 => foo]
  // ~~~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_ArrayPattern;

// Represents an array pattern *with trailing comma* used in pattern matching
//
// It's slightly different from `ArrayPattern`, trailing comma at the end works as `, *`
//
typedef struct LIB_RUBY_PARSER_ArrayPatternWithTail {
  // A list of elements
  //
  struct LIB_RUBY_PARSER_NodeList elements;
  // Location of the open bracket
  //
  // ```text
  // [1, ^a, 3 => foo,]
  // ~
  // ```
  //
  // `None` for pattern like `1, 2,` without brackets
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of the closing bracket
  //
  // ```text
  // [1, ^a, 3 => foo,]
  //                  ~
  // ```
  //
  // `None` for pattern like `1, 2,` without brackets
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the full expression
  //
  // ```text
  // [1, ^a, 3 => foo,]
  // ~~~~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_ArrayPatternWithTail;

// Represents special global variables:
//     1. `` $` ``
//     2. `$&`
//     3. `$'`
//     4. `$+`
//
typedef struct LIB_RUBY_PARSER_BackRef {
  // Name of the variable (`"$+"` for `$+`)
  //
  struct LIB_RUBY_PARSER_StringPtr name;
  // Location of the full expression
  //
  // ```text
  // $+
  // ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_BackRef;

// Represents compound statement (i.e. a multi-statement)
//
// Basically all blocks of code are wrapped into `Begin` node (e.g. method/block body, rescue/ensure handler etc)
//
typedef struct LIB_RUBY_PARSER_Begin {
  // A list of statements
  //
  struct LIB_RUBY_PARSER_NodeList statements;
  // Begin of the block
  //
  // ```text
  // (1; 2)
  // ~
  // ```
  //
  // `None` if the block of code is "implicit", like
  //
  // ```text
  // if true; 1; 2; end
  // ```
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // End of the block
  //
  // ```text
  // (1; 2)
  //      ~
  // ```
  //
  // `None` if the block of code is "implicit", like
  //
  // ```text
  // if true; 1; 2; end
  // ```
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the full expression
  //
  // ```text
  // (1; 2)
  // ~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Begin;

// Represents a Ruby block that is passed to a method (`proc { |foo| bar }`)
//
typedef struct LIB_RUBY_PARSER_Block {
  // Method call that takes a block
  //
  // `Send("foo")` in `foo {}`
  //
  LIB_RUBY_PARSER_Ptr_Node call;
  // A list of argument that block takes
  //
  // `vec![ Arg("a"), Optarg("b", Int("1")) ]` for `proc { |a, b = 1| }`
  //
  // `None` if the block takes no arguments
  //
  LIB_RUBY_PARSER_MaybePtr_Node args;
  // Block body, `None` if block has no body.
  //
  LIB_RUBY_PARSER_MaybePtr_Node body;
  // Location of the open brace
  //
  // ```text
  // proc { }
  //      ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc begin_l;
  // Location of the closing brace
  //
  // ```text
  // proc { }
  //        ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc end_l;
  // Location of the full expression
  //
  // ```text
  // proc { }
  // ~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Block;

// Represents a `&blk` argument of the method call (but not of the method definition, see `BlockArg`)
//
typedef struct LIB_RUBY_PARSER_BlockPass {
  // Value that is converted to a block
  //
  // `Int("1")` in `foo(&1)` (yes, it's possible)
  //
  LIB_RUBY_PARSER_Ptr_Node value;
  // Location of the `&` operator
  //
  // ```text
  // foo(&blk)
  //     ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the full expression
  //
  // ```text
  // foo(&bar)
  //     ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_BlockPass;

// Represents a `&blk` argument in the method definition (but not in the method call, see `BlockPass`)
//
typedef struct LIB_RUBY_PARSER_Blockarg {
  // Name of the argument, `String("foo")` for `def m(&foo)`
  //
  struct LIB_RUBY_PARSER_StringPtr name;
  // Location of the `&` operator
  //
  // ```text
  // def m(&foo); end
  //       ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the name
  //
  // ```text
  // def m(&foo); end
  //        ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc name_l;
  // Location of the full expression
  //
  // ```text
  // def m(&foo); end
  //       ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Blockarg;

// Represents a `break` keyword (with optional argument)
//
typedef struct LIB_RUBY_PARSER_Break {
  // A list of arguments
  //
  struct LIB_RUBY_PARSER_NodeList args;
  // Location of the `break` keyword
  //
  // ```text
  // break :foo
  // ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the full expression
  //
  // ```text
  // break(:foo)
  // ~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Break;

// Represents a `case` statement (for pattern matching see `CaseMatch` node)
//
typedef struct LIB_RUBY_PARSER_Case {
  // Expression given to `case`, `Int("1")` for `case 1; end`
  // `None` for code like
  //
  // ```text
  // case
  // when pattern
  // end
  // ```
  //
  LIB_RUBY_PARSER_MaybePtr_Node expr;
  // A list of `When` nodes (each has `patterns` and `body`)
  //
  struct LIB_RUBY_PARSER_NodeList when_bodies;
  // Body of the `else` branch, `None` if there's no `else` branch
  //
  LIB_RUBY_PARSER_MaybePtr_Node else_body;
  // Location of the `case` keyword
  //
  // ```text
  // case 1; end
  // ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the `else` keyword
  //
  // ```text
  // case 1; else; end
  //         ~~~~
  // ```
  //
  // `None` if there's no `else` branch
  //
  struct LIB_RUBY_PARSER_MaybeLoc else_l;
  // Location of the `end` keyword
  //
  // ```text
  // case 1; end
  //         ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc end_l;
  // Location of the full expression
  //
  // ```text
  // case 1; end
  // ~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Case;

// Represents a `case` statement used for pattern matching (for regular `case` see `Case` node)
//
typedef struct LIB_RUBY_PARSER_CaseMatch {
  // Expression given to `case`, `Int("1")` for `case 1; in 1; end`
  // `None` for code like
  //
  // ```text
  // case
  // in pattern
  // end
  // ```
  //
  LIB_RUBY_PARSER_Ptr_Node expr;
  // A list of `InPattern` nodes (each has `pattern`, `guard` and `body`)
  //
  struct LIB_RUBY_PARSER_NodeList in_bodies;
  // Body of the `else` branch, `None` if there's no `else` branch
  //
  LIB_RUBY_PARSER_MaybePtr_Node else_body;
  // Location of the `case` keyword
  //
  // ```text
  // case 1; in 2; end
  // ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the `else` keyword
  //
  // ```text
  // case 1; in 2; else; end
  //               ~~~~
  // ```
  //
  // `None` if there's no `else` branch
  //
  struct LIB_RUBY_PARSER_MaybeLoc else_l;
  // Location of the `end` keyword
  //
  // ```text
  // case 1; in 2; end
  //               ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc end_l;
  // Location of the full expression
  //
  // ```text
  // case 1; in 2; end
  // ~~~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_CaseMatch;

// Represents a constant assignment (i.e. `A = 1`)
//
typedef struct LIB_RUBY_PARSER_Casgn {
  // Scope where the constant is defined:
  //     1. `Some(Const("A"))` for `A::B = 1`
  //     2. `None` if it's defined in the current scope (i.e. `A = 1`)
  //     3. `Some(Cbase)` if it's defined in the global scope (i.e. `::A = 1`)
  //
  LIB_RUBY_PARSER_MaybePtr_Node scope;
  // Name of the constant, `String("A")` for `A = 1`
  //
  struct LIB_RUBY_PARSER_StringPtr name;
  // Value that is assigned to a constant, `Int("1")` for `A = 1`.
  //
  // **Note**: `None` if constant assignment is a part of the multi-assignment.
  // In such case `value` belongs to `Masgn` node of the multi-assignment.
  //
  LIB_RUBY_PARSER_MaybePtr_Node value;
  // Location of the `::` operator
  //
  // ```text
  // A::B = 1
  //  ~~
  //
  // ::A = 1
  // ~~
  // ```
  //
  // `None` if the constant is defined in the current scope
  //
  struct LIB_RUBY_PARSER_MaybeLoc double_colon_l;
  // Location of the constant name
  //
  // ```text
  // A::CONST = 1
  //    ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc name_l;
  // Location of the `=` operator
  //
  // ```text
  // A = 1
  //   ~
  // ```
  //
  // `None` if constant assignment is a part of the multi-assignment.
  // In such case `=` belongs to a `Masgn` node
  //
  struct LIB_RUBY_PARSER_MaybeLoc operator_l;
  // Location of the full expression
  //
  // ```text
  // A = 1
  // ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Casgn;

// Represents leading `::` part of the constant access/assignment that is used to get/set on a global namespace.
//
typedef struct LIB_RUBY_PARSER_Cbase {
  // Location of the full expression
  //
  // ```text
  // ::A
  // ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Cbase;

// Represents a class definition (using a `class` keyword, `Class.new` is just a method call)
//
typedef struct LIB_RUBY_PARSER_Class {
  // Name of the class, `String("Foo")` for `class Foo; end`
  //
  LIB_RUBY_PARSER_Ptr_Node name;
  // Superclass. Can be an expression in cases like `class A < (obj.foo + 1); end`
  //
  // `None` if no explicit superclass given (i.e. `class Foo; end`)
  //
  LIB_RUBY_PARSER_MaybePtr_Node superclass;
  // Body of the method, `None` if there's no body.
  //
  LIB_RUBY_PARSER_MaybePtr_Node body;
  // Location of the `class` keyword.
  //
  // ```text
  // class Foo; end
  // ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the `<` operator
  //
  // ```text
  // class A < B; end
  //         ~
  // ```
  //
  // `None` if there's no explicit superclass given.
  //
  struct LIB_RUBY_PARSER_MaybeLoc operator_l;
  // Location of the `end` keyword.
  //
  // ```text
  // class Foo; end
  //            ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc end_l;
  // Location of the full expression
  //
  // ```text
  // class Foo; end
  // ~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Class;

// Represents a `Complex` literal (that returns an `Complex` number)
//
typedef struct LIB_RUBY_PARSER_Complex {
  // Value of the complex literal, returned as a `String`, `String("1i")` for `1i`
  //
  struct LIB_RUBY_PARSER_StringPtr value;
  // Location of the `-` (but not `+`) operator. `+` is a part of the literal:
  //     1. `+1i` is `String("+1i")` with `operator = None`
  //     2. `-1i` is `String("1i")` with `operator = String("-")`
  //
  // ```text
  // -1i
  // ~
  // ```
  //
  struct LIB_RUBY_PARSER_MaybeLoc operator_l;
  // Location of the full expression
  //
  // ```text
  // -1i
  // ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Complex;

// Represents constant access (i.e. `Foo::Bar`)
//
typedef struct LIB_RUBY_PARSER_Const {
  // Scope where the constant is taken from:
  //     1. `Some(Const("A"))` for `A::B`
  //     2. `None` if it's taken from the current scope (i.e. `A`)
  //     3. `Some(Cbase)` if it's taken from the global scope (i.e. `::A`)
  //
  LIB_RUBY_PARSER_MaybePtr_Node scope;
  // Name of the constant, `String("Foo")` for `Foo`
  //
  struct LIB_RUBY_PARSER_StringPtr name;
  // Location of the `::` operator. `None` if constant is taken from the current scope.
  //
  // ```text
  // A::B
  //  ~~
  // ```
  //
  struct LIB_RUBY_PARSER_MaybeLoc double_colon_l;
  // Location of the constant name
  //
  // ```text
  // Foo::Bar
  //      ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc name_l;
  // Location of the full expression
  //
  // ```text
  // Foo::Bar
  // ~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Const;

// Const pattern used in pattern matching (e.g. `in A(1, 2)`)
//
typedef struct LIB_RUBY_PARSER_ConstPattern {
  // Constant that is used, `Const("Foo")` for `in For(42)`
  //
  LIB_RUBY_PARSER_Ptr_Node const_;
  // Inner part of the constant pattern
  //
  // `ArrayPattern(vec![ Int("1") ])` for `Foo(1)`
  //
  LIB_RUBY_PARSER_Ptr_Node pattern;
  // Location of the open parenthesis
  //
  // ```text
  // case 1; in Foo(42); end
  //               ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc begin_l;
  // Location of the closing parenthesis
  //
  // ```text
  // case 1; in Foo(42); end
  //                  ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc end_l;
  // Location of the full expression
  //
  // ```text
  // case 1; in Foo(42); end
  //            ~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_ConstPattern;

// Represents conditional method call using `&.` operator
//
typedef struct LIB_RUBY_PARSER_CSend {
  // Receiver of the method call, `Int("1")` for `1&.foo`
  //
  LIB_RUBY_PARSER_Ptr_Node recv;
  // Name of the method, `String("foo")` for `1&.foo`
  //
  struct LIB_RUBY_PARSER_StringPtr method_name;
  // List of arguments
  //
  // ```text
  // foo&.bar(42)
  // # and also setters like
  // foo&.bar = 42
  // ```
  //
  struct LIB_RUBY_PARSER_NodeList args;
  // Location of the `&.` operator
  //
  // ```text
  // foo&.bar
  //    ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc dot_l;
  // Location of the method name
  //
  // ```text
  // foo&.bar(42)
  //      ~~~
  // ```
  //
  // `None` in a very special case when method call is implicit (i.e. `foo&.()`)
  //
  struct LIB_RUBY_PARSER_MaybeLoc selector_l;
  // Location of the open parenthesis
  //
  // ```text
  // foo&.bar(42)
  //         ~
  // ```
  //
  // `None` if there are no parentheses
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of the closing parenthesis
  //
  // ```text
  // foo&.bar(42)
  //            ~
  // ```
  //
  // `None` if there are no parentheses
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the operator if `CSend` is a part of assignment like
  //
  // ```text
  // foo&.bar = 1
  //          ~
  // ```
  //
  // `None` for a regular call.
  //
  struct LIB_RUBY_PARSER_MaybeLoc operator_l;
  // Location of the full expression
  //
  // ```text
  // foo&.bar(42)
  // ~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_CSend;

// Represents access to class variable (i.e. `@@var`)
//
typedef struct LIB_RUBY_PARSER_Cvar {
  // Name of the class variable, `String("@@foo")` for `@@foo`
  //
  struct LIB_RUBY_PARSER_StringPtr name;
  // Location of the full expression
  //
  // ```text
  // @@foo
  // ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Cvar;

// Represents class variable assignment (i.e. `@@var = 42`)
//
typedef struct LIB_RUBY_PARSER_Cvasgn {
  // Name of the class variable, `String("@@foo")` for `@@foo = 1`
  //
  struct LIB_RUBY_PARSER_StringPtr name;
  // Value that is assigned to class variable, `Int("1")` for `@@foo = 1`
  //
  LIB_RUBY_PARSER_MaybePtr_Node value;
  // Location of the class variable name
  //
  // ```text
  // @@foo = 1
  // ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc name_l;
  // Location of the `=` operator
  //
  // ```text
  // @@foo = 1
  //       ~
  // ```
  //
  struct LIB_RUBY_PARSER_MaybeLoc operator_l;
  // Location of the full expression
  //
  // ```text
  // @@foo = 1
  // ~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Cvasgn;

// Represents method definition using `def` keyword (not on a singleton, see `Defs` node).
//
typedef struct LIB_RUBY_PARSER_Def {
  // Name of the method, `String("foo")` for `def foo; end`
  //
  struct LIB_RUBY_PARSER_StringPtr name;
  // Arguments of a method, `None` if there's no arguments.
  //
  // All information about parentheses around arguments is stored in this node.
  //
  LIB_RUBY_PARSER_MaybePtr_Node args;
  // Body of a method, `None` if there's no body.
  //
  LIB_RUBY_PARSER_MaybePtr_Node body;
  // Location of the `def` keyword.
  //
  // ```text
  // def foo; end
  // ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the method name.
  //
  // ```text
  // def foo; end
  //     ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc name_l;
  // Location of the `end` keyword.
  //
  // ```text
  // def foo; end
  //          ~~~
  // ```
  //
  // `None` for endless method definition
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the `=` operator for endless method definition
  //
  // ```text
  // def m() = 1
  //         ~
  // ```
  //
  // `None` for regular method definition
  //
  struct LIB_RUBY_PARSER_MaybeLoc assignment_l;
  // Location of the full expression
  //
  // ```text
  // def m(a); foo; end
  // ~~~~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Def;

// Represents a `defined?(foo)` expression
//
typedef struct LIB_RUBY_PARSER_Defined {
  // Value given to `defined?`
  //
  LIB_RUBY_PARSER_Ptr_Node value;
  // Location of the `defined?` keyword
  //
  // ```text
  // defined?(foo)
  // ~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the open parenthesis
  //
  // ```text
  // defined?(foo)
  //         ~
  // ```
  //
  // `None` if there are no parentheses
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of the closing parenthesis
  //
  // ```text
  // defined?(foo)
  //             ~
  // ```
  //
  // `None` if there are no parentheses
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the full expression
  //
  // ```text
  // defined?(foo)
  // ~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Defined;

// Represents a singleton method definition (i.e. `def self.foo; end`)
//
typedef struct LIB_RUBY_PARSER_Defs {
  // Definee of a method definition, `Lvar("x")` for `def x.foo; end
  //
  LIB_RUBY_PARSER_Ptr_Node definee;
  // Name of the method, `String("foo")` for `def x.foo; end`
  //
  struct LIB_RUBY_PARSER_StringPtr name;
  // Arguments of a method, `None` if there's no arguments.
  //
  // All information about parentheses around arguments is stored in this node.
  //
  LIB_RUBY_PARSER_MaybePtr_Node args;
  // Body of the method, `None` if there's no body.
  //
  LIB_RUBY_PARSER_MaybePtr_Node body;
  // Location of the `def` keyword
  //
  // ```text
  // def self.foo; end
  // ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the `.`
  //
  // ```text
  // def self.foo; end
  //         ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the method name
  //
  // ```text
  // def self.foo; end
  //          ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc name_l;
  // Location of the `=` operator for endless method definition
  //
  // ```text
  // def self.foo() = 42
  //                ~
  // ```
  //
  // `None` for regular method definition
  //
  struct LIB_RUBY_PARSER_MaybeLoc assignment_l;
  // Location of the `end` keyword
  //
  // ```text
  // def self.foo; end
  //               ~~~
  // ```
  //
  // `None` for endless method definition
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the full expression
  //
  // ```text
  // def self.foo; end
  // ~~~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Defs;

// Represents a string with interpolation (i.e. `"#{foo}"`)
//
typedef struct LIB_RUBY_PARSER_Dstr {
  // A list of string parts (static literals and interpolated expressions)
  //
  struct LIB_RUBY_PARSER_NodeList parts;
  // Location of the string begin
  //
  // ```text
  // "#{foo}"
  // ~
  //
  // %Q{#{foo}}
  // ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of the string end
  //
  // ```text
  // "#{foo}"
  //        ~
  //
  // %Q{#{foo}}
  //          ~
  // ```
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the full expression
  //
  // ```text
  // "#{foo}"
  // ~~~~~~~~
  //
  // %Q{#{foo}}
  // ~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Dstr;

// Represents a symbol with interpolation (i.e. `:"#{foo}"`)
//
typedef struct LIB_RUBY_PARSER_Dsym {
  // A list of symbol parts (static literals and interpolated expressions)
  //
  struct LIB_RUBY_PARSER_NodeList parts;
  // Location of the symbol begin
  //
  // ```text
  // :"#{foo}"
  // ~~
  // ```
  //
  // `None` if `Dsym` is a part of the interpolated symbol array:
  //
  // ```text
  // %I[#{bar}]
  // ```
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of the symbol begin
  //
  // ```text
  // :"#{foo}"
  //         ~
  // ```
  //
  // `None` if `Dsym` is a part of the interpolated symbol array:
  //
  // ```text
  // %I[#{bar}]
  // ```
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the full expression
  //
  // ```text
  // :"#{foo}"
  // ~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Dsym;

// Represents exclusive flip-flop (i.e. in `if foo...bar; end`)
//
typedef struct LIB_RUBY_PARSER_EFlipFlop {
  // Left part of the flip-flop. `None` if based on a range without begin (`...bar`)
  //
  LIB_RUBY_PARSER_MaybePtr_Node left;
  // Right part of the flip-flop. `None` if based on a range without end (`foo...`)
  //
  LIB_RUBY_PARSER_MaybePtr_Node right;
  // Location of the `...` operator
  //
  // ```text
  // if foo...bar; end
  //       ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the full expression
  //
  // ```text
  // if foo...bar; end
  //    ~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_EFlipFlop;

// Represents a special empty else that is a part of the pattern matching.
//
// Usually empty else (e.g. part of the `if` statement) doesn't mean anything,
// however in pattern matching it prevents raising a `NoPatternError`.
//
// Throwing away this `else` may affect your code.
//
typedef struct LIB_RUBY_PARSER_EmptyElse {
  // Location of the `else` keyword
  //
  // ```text
  // case foo; in 1; else; end
  //                 ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_EmptyElse;

// Represents a special `__ENCODING__` keyword
//
typedef struct LIB_RUBY_PARSER_Encoding {
  // Location of the `__ENCODING__` keyword
  //
  // ```text
  // __ENCODING__
  // ~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Encoding;

// Represents a block of code with `ensure` (i.e. `begin; ensure; end`)
//
typedef struct LIB_RUBY_PARSER_Ensure {
  // Block of code that is wrapped into `ensure`
  // **Note**: that's the body of the `ensure` block
  //
  // `Int("1")` for `begin; 1; ensure; 2; end`
  //
  LIB_RUBY_PARSER_MaybePtr_Node body;
  // Body of the `ensure` block
  //
  // `Int("2")` for `begin; 1; ensure; 2; end`
  //
  LIB_RUBY_PARSER_MaybePtr_Node ensure;
  // Location of the `ensure` keyword
  //
  // ```text
  // begin; ensure; end
  //        ~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the full expression
  //
  // ```text
  // begin; 1; rescue; 2; else; 3; ensure; 4; end
  //        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  // ```
  //
  // **Note**: begin/end belong to `KwBegin` node.
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Ensure;

// Represents range literal with excluded `end` (i.e. `1...3`)
typedef struct LIB_RUBY_PARSER_Erange {
  // Begin of the range, `None` if range has no begin (i.e `...42`)
  //
  LIB_RUBY_PARSER_MaybePtr_Node left;
  // End of the range, `None` if range has no end (i.e `42...`)
  //
  LIB_RUBY_PARSER_MaybePtr_Node right;
  // Location of the `...` operator
  //
  // ```text
  // 1...3
  //  ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the full expression
  //
  // ```text
  // 1...3
  // ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Erange;

// Represents a `false` literal
//
typedef struct LIB_RUBY_PARSER_False {
  // Location of the `false` literal
  //
  // ```text
  // false
  // ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_False;

// Represents a special `__FILE__` literal
//
typedef struct LIB_RUBY_PARSER_File {
  // Location of the `__FILE__` literal
  //
  // ```text
  // __FILE__
  // ~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_File;

// Represents a find pattern using in pattern matching (i.e. `in [*x, 1 => a, *y]`)
//
// It's different from `ArrayPattern`/`ConstPattern` because it supports multiple wildcard pattern
//
typedef struct LIB_RUBY_PARSER_FindPattern {
  // Inner part of the find pattern
  //
  struct LIB_RUBY_PARSER_NodeList elements;
  // Location of the begin
  //
  // ```text
  // case foo; in [*x, 1 => a, *y]; end
  //              ~
  // ```
  //
  // `None` if there are no brackets/parentheses
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of the end
  //
  // ```text
  // case foo; in [*x, 1 => a, *y]; end
  //                             ~
  // ```
  //
  // `None` if there are no brackets/parentheses
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the full expression
  //
  // ```text
  // case foo; in [*x, 1 => a, *y]; end
  //              ~~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_FindPattern;

// Represents a float literal (i.e. `42.5`)
//
typedef struct LIB_RUBY_PARSER_Float {
  // String value of the literal, `String("42.5")` for `42.5`
  //
  struct LIB_RUBY_PARSER_StringPtr value;
  // Location of unary `-` (but not `+`)
  //
  // ```text
  // -42.5
  // ~
  // ```
  //
  struct LIB_RUBY_PARSER_MaybeLoc operator_l;
  // Location of the full expression
  //
  // ```text
  // -42.5
  // ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Float;

// Represents a `for` loop
//
typedef struct LIB_RUBY_PARSER_For {
  // Variable that is used in loop, `Lvasgn("a")` in `for a in b; end`
  //
  LIB_RUBY_PARSER_Ptr_Node iterator;
  // Collection that is for iteration. `Lvar("b")` in `for a in b; end`
  //
  LIB_RUBY_PARSER_Ptr_Node iteratee;
  // Body of the loop. `None` if there's no body
  //
  LIB_RUBY_PARSER_MaybePtr_Node body;
  // Location of the `for` keyword
  //
  // ```text
  // for a in b; end
  // ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the `in` keyword
  //
  // ```text
  // for a in b; end
  //       ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the `do` keyword
  //
  // ```text
  // for a in b do; end
  //            ~~
  // ```
  //
  // **Note**: this `do` is optional, and so `begin_l` can be `None`.
  //
  struct LIB_RUBY_PARSER_Loc begin_l;
  // Location of the `end` keyword
  //
  // ```text
  // for a in b; end
  //             ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc end_l;
  // Location of the full expression
  //
  // ```text
  // for a in b; end
  // ~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_For;

// Represents a special `...` argument that forwards positional/keyword/block arguments.
//
typedef struct LIB_RUBY_PARSER_ForwardArg {
  // Location of the `...`
  //
  // ```text
  // def m(...); end
  //       ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_ForwardArg;

// Represents a `...` operator that contains forwarded argument (see `ForwardArg`)
//
typedef struct LIB_RUBY_PARSER_ForwardedArgs {
  // Location of the `...`
  //
  // ```text
  // def m(...); foo(...); end
  //                 ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_ForwardedArgs;

// Represents access to global variable (i.e. `$foo`)
//
typedef struct LIB_RUBY_PARSER_Gvar {
  // Name of the global variable, `String("$foo")` for `$foo`
  //
  struct LIB_RUBY_PARSER_StringPtr name;
  // Location of the full expression
  //
  // ```text
  // $foo
  // ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Gvar;

// Represents global variable assignment (i.e. `$foo = 42`)
//
typedef struct LIB_RUBY_PARSER_Gvasgn {
  // Name of the global variable, `String("$foo")` for `$foo`
  //
  struct LIB_RUBY_PARSER_StringPtr name;
  // Value that is assigned to global variable, `Int("42")` for `$foo = 42`
  //
  // `None` if global variable assignment is a part of the multi-assignment.
  // In such case `value` is a part of the `Masgn` node.
  //
  LIB_RUBY_PARSER_MaybePtr_Node value;
  // Location of the global variable name
  //
  // ```text
  // $foo = 42
  // ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc name_l;
  // Location of the `=` operator
  //
  // ```text
  // $foo = 42
  //      ~
  // ```
  //
  // `None` if global variable assignment is a part of the multi-assignment.
  // In such case `=` operator belongs to the `Masgn` node.
  //
  struct LIB_RUBY_PARSER_MaybeLoc operator_l;
  // Location of the full expression
  //
  // ```text
  // $foo = 42
  // ~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Gvasgn;

// Represents a hash literal (i.e. `{ foo: 42 }`)
//
typedef struct LIB_RUBY_PARSER_Hash {
  // A list of key-value pairs
  //
  struct LIB_RUBY_PARSER_NodeList pairs;
  // Location of the open parenthesis
  //
  // ```text
  // { a: 1 }
  // ~
  // ```
  //
  // `None` if hash literal is implicit, e.g. `foo(key: "value")`
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of the closing parenthesis
  //
  // ```text
  // { a: 1 }
  //        ~
  // ```
  //
  // `None` if hash literal is implicit, e.g. `foo(key: "value")`
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the full expression
  //
  // ```text
  // { a: 1 }
  // ~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Hash;

// Represents kwargs that are given to a method call, super or yield (i.e. `foo(bar: 1)`)
//
typedef struct LIB_RUBY_PARSER_Kwargs {
  // A list of key-value pairs
  //
  struct LIB_RUBY_PARSER_NodeList pairs;
  // Location of the full expression
  //
  // ```text
  // foo(bar: 1)
  //     ~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Kwargs;

// Represents a hash pattern used in pattern matching (i.e. `in { a: 1 }`)
//
typedef struct LIB_RUBY_PARSER_HashPattern {
  // A list of inner patterns
  //
  struct LIB_RUBY_PARSER_NodeList elements;
  // Location of the open parenthesis
  //
  // ```text
  // case foo; in { a: 1 }; end
  //              ~
  // ```
  //
  // `None` if there are no parentheses
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of the open parenthesis
  //
  // ```text
  // case foo; in { a: 1 }; end
  //                     ~
  // ```
  //
  // `None` if there are no parentheses
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the full expression
  //
  // ```text
  // case foo; in { a: 1 }; end
  //              ~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_HashPattern;

// Represents a here-document literal (both with and without interpolation)
//
// It's similar to `Dstr` in terms of abstract syntax tree, but has different source maps.
//
typedef struct LIB_RUBY_PARSER_Heredoc {
  // A list of string parts (static literals and interpolated expressions)
  //
  struct LIB_RUBY_PARSER_NodeList parts;
  // Location of the here-document body
  //
  // ```text
  // <<-HERE\n  a\n   #{42}\nHERE
  //          ~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc heredoc_body_l;
  // Location of the here-document end
  //
  // ```text
  // <<-HERE\n  a\n   #{42}\nHERE
  //                         ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc heredoc_end_l;
  // Location of the here-document identifier
  //
  // ```text
  // <<-HERE\n  a\n   #{42}\nHERE
  // ~~~~~~~
  // ```
  //
  // **Note**: This is the only node (with `XHeredoc`) that has `expression_l` smaller that all other sub-locations merged.
  // The reason for that is that it's possible to add more code after here-document ID:
  //
  // ```text
  // <<-HERE + "rest"
  //   content
  // HERE
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Heredoc;

// Represents an `if` statement (i.e. `if foo; bar; else; baz; end`)
//
typedef struct LIB_RUBY_PARSER_If {
  // Condition given to the `if` statement, `Lvar("a")` for `if a; b; else; c; end`
  //
  LIB_RUBY_PARSER_Ptr_Node cond;
  // True-branch of the `if` statement, `Lvar("b")` for `if a; b; else; c; end`
  //
  LIB_RUBY_PARSER_MaybePtr_Node if_true;
  // False-branch of the `if` statement, `Lvar("c")` for `if a; b; else; c; end`
  //
  LIB_RUBY_PARSER_MaybePtr_Node if_false;
  // Location of the `if` keyword
  //
  // ```text
  // if foo; end
  // ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the `then` keyword
  //
  // ```text
  // if foo then; end
  //        ~~~~
  // ```
  //
  // `None` if `then` keyword is omitted
  //
  struct LIB_RUBY_PARSER_Loc begin_l;
  // Location of the `else` keyword
  //
  // ```text
  // if foo; else; end
  //         ~~~~
  // ```
  //
  // `None` if there's no `else` branch
  //
  struct LIB_RUBY_PARSER_MaybeLoc else_l;
  // Location of the `end` keyword
  //
  // ```text
  // if foo; end
  //         ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the full expression
  //
  // ```text
  // if a then; b; else; c end
  // ~~~~~~~~~~~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_If;

// Represents an `if` guard used in pattern matching (i.e. `case foo; in pattern if guard; end`)
//
typedef struct LIB_RUBY_PARSER_IfGuard {
  // Condition of the guard, `Lvar("foo")` in `in pattern if guard`
  //
  LIB_RUBY_PARSER_Ptr_Node cond;
  // Location of the `if` keyword
  //
  // ```text
  // case foo; in pattern if cond; end
  //                      ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the full expression
  //
  // ```text
  // case foo; in pattern if cond; end
  //                      ~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_IfGuard;

// Represents an `if`/`unless` modifier (i.e. `stmt if cond`)
//
typedef struct LIB_RUBY_PARSER_IfMod {
  // Condition of the modifier
  //
  LIB_RUBY_PARSER_Ptr_Node cond;
  // True-branch of the modifier.
  //
  // Always set for `if` modifier.
  // Always `None` for `unless` modifier.
  //
  LIB_RUBY_PARSER_MaybePtr_Node if_true;
  // False-branch of the modifier.
  //
  // Always set for `unless` modifier.
  // Always `None` for `if` modifier.
  //
  LIB_RUBY_PARSER_MaybePtr_Node if_false;
  // Location of the `if`/`unless` keyword
  //
  // ```text
  // stmt if cond
  //      ~~
  //
  // stmt unless cond
  //      ~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the full expression
  //
  // ```text
  // stmt if cond
  // ~~~~~~~~~~~~
  //
  // stmt unless cond
  // ~~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_IfMod;

// Represents ternary `if` statement (i.e. `cond ? if_true : if_false`)
//
typedef struct LIB_RUBY_PARSER_IfTernary {
  // Condition of the `if` statement
  //
  LIB_RUBY_PARSER_Ptr_Node cond;
  // True-branch
  //
  LIB_RUBY_PARSER_Ptr_Node if_true;
  // True-branch
  //
  LIB_RUBY_PARSER_Ptr_Node if_false;
  // Location of the `?` operator
  //
  // ```text
  // cond ? if_true : if_false
  //      ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc question_l;
  // Location of the `:` operator
  //
  // ```text
  // cond ? if_true : if_false
  //                ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc colon_l;
  // Location of the full expression
  //
  // ```text
  // cond ? if_true : if_false
  // ~~~~~~~~~~~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_IfTernary;

// Represents inclusive flip-flop (i.e. in `if foo..bar; end`)
//
typedef struct LIB_RUBY_PARSER_IFlipFlop {
  // Left part of the flip-flop. `None` if based on a range without begin (`..bar`)
  //
  LIB_RUBY_PARSER_MaybePtr_Node left;
  // Right part of the flip-flop. `None` if based on a range without end (`foo..`)
  //
  LIB_RUBY_PARSER_MaybePtr_Node right;
  // Location of the `..` operator
  //
  // ```text
  // if foo..bar; end
  //       ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the full expression
  //
  // ```text
  // if foo..bar; end
  //    ~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_IFlipFlop;

// Represents a one-line pattern matching that can throw an error (i.e. `foo => pattern`)
//
typedef struct LIB_RUBY_PARSER_MatchPattern {
  // Value that is used for matching
  //
  LIB_RUBY_PARSER_Ptr_Node value;
  // Pattern that is used for matching
  //
  LIB_RUBY_PARSER_Ptr_Node pattern;
  // Location of the `=>` operator
  //
  // ```text
  // foo => pattern
  //     ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the full expression
  //
  // ```text
  // foo => pattern
  // ~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_MatchPattern;

// Represents a one-line pattern matching that never throws but returns true/false (i.e. `foo in pattern`)
//
typedef struct LIB_RUBY_PARSER_MatchPatternP {
  // Value that is used for matching
  //
  LIB_RUBY_PARSER_Ptr_Node value;
  // Pattern that is used for matching
  //
  LIB_RUBY_PARSER_Ptr_Node pattern;
  // Location of the `in` operator
  //
  // ```text
  // foo in pattern
  //     ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the full expression
  //
  // ```text
  // foo in pattern
  // ~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_MatchPatternP;

// Represents an `in pattern` branch of the pattern matching
//
typedef struct LIB_RUBY_PARSER_InPattern {
  // Value that is used for matching
  //
  LIB_RUBY_PARSER_Ptr_Node pattern;
  // Guard that is used for matching
  //
  // Optional, so can be `None`
  //
  LIB_RUBY_PARSER_MaybePtr_Node guard;
  // Body of the branch that is invoked if value matches pattern
  //
  LIB_RUBY_PARSER_MaybePtr_Node body;
  // Location of the `in` keyword
  //
  // ```text
  // case value; in pattern; end
  //             ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the `then` keyword
  //
  // ```text
  // case value; in pattern then; end
  //                        ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc begin_l;
  // Location of the full expression
  //
  // ```text
  // case value; in pattern then; 42; end
  //             ~~~~~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_InPattern;

// Represents indexing operation (i.e. `foo[1,2,3]`)
//
typedef struct LIB_RUBY_PARSER_Index {
  // Receiver of indexing
  //
  LIB_RUBY_PARSER_Ptr_Node recv;
  // A list of indexes
  //
  struct LIB_RUBY_PARSER_NodeList indexes;
  // Location of open bracket
  //
  // ```text
  // foo[1, 2, 3]
  //    ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc begin_l;
  // Location of closing bracket
  //
  // ```text
  // foo[1, 2, 3]
  //            ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc end_l;
  // Location of the full expression
  //
  // ```text
  // foo[1, 2, 3]
  // ~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Index;

// Represents assignment using indexing operation (i.e. `foo[1, 2, 3] = bar`)
//
typedef struct LIB_RUBY_PARSER_IndexAsgn {
  // Receiver of the indexing
  //
  LIB_RUBY_PARSER_Ptr_Node recv;
  // A list of indexes
  //
  struct LIB_RUBY_PARSER_NodeList indexes;
  // Value that is assigned
  //
  // `None` if assignment is a part of the multi-assignment.
  // In such case `value` belongs to `Masgn` node.
  //
  LIB_RUBY_PARSER_MaybePtr_Node value;
  // Location of open bracket
  //
  // ```text
  // foo[1, 2, 3] = bar
  //    ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc begin_l;
  // Location of closing bracket
  //
  // ```text
  // foo[1, 2, 3] = bar
  //            ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc end_l;
  // Location of the `=` operator
  //
  // ```text
  // foo[1, 2, 3] = bar
  //              ~
  // ```
  //
  // `None` if assignment is a part of the multi-assignment.
  // In such case operator `=` belongs to `Masgn` node.
  //
  struct LIB_RUBY_PARSER_MaybeLoc operator_l;
  // Location of the full expression
  //
  // ```text
  // foo[1, 2, 3] = bar
  // ~~~~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_IndexAsgn;

// Represents an integer literal (i.e. `42`)
//
typedef struct LIB_RUBY_PARSER_Int {
  // String value of the literal, `String("42")` for `42`
  //
  struct LIB_RUBY_PARSER_StringPtr value;
  // Location of unary `-` (but not `+`)
  //
  // ```text
  // -42
  // ~
  // ```
  //
  struct LIB_RUBY_PARSER_MaybeLoc operator_l;
  // Location of the full expression
  //
  // ```text
  // -42
  // ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Int;

// Represents inclusive range (i.e. `2..4`)
//
typedef struct LIB_RUBY_PARSER_Irange {
  // Begin of the range, `None` if range has no `begin` (i.e. `..4`)
  //
  LIB_RUBY_PARSER_MaybePtr_Node left;
  // End of the range, `None` if range has no `end` (i.e. `2..`)
  //
  LIB_RUBY_PARSER_MaybePtr_Node right;
  // Location of the `..` operator
  //
  // ```text
  // 2..4
  //  ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the full expression
  //
  // ```text
  // 2..4
  // ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Irange;

// Represents access to instance variable (i.e. `@foo`)
//
typedef struct LIB_RUBY_PARSER_Ivar {
  // Name of the instance variable, `String("@foo")` in `@foo`
  //
  struct LIB_RUBY_PARSER_StringPtr name;
  // Location of the full expression
  //
  // ```text
  // @foo
  // ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Ivar;

// Represents instance variable assignment (i.e `@foo = 42`)
//
typedef struct LIB_RUBY_PARSER_Ivasgn {
  // Name of the instance variable, `String("@foo")` in `@foo = 42`
  //
  struct LIB_RUBY_PARSER_StringPtr name;
  // Value that is assigned to instance variable.
  //
  // `None` if instance variable assignment is a part of the multi-assignment.
  // In such case `value` is a part of the `Masgn` node.
  //
  LIB_RUBY_PARSER_MaybePtr_Node value;
  // Location of the instance variable name.
  //
  // ```text
  // @foo = 1
  // ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc name_l;
  // Location of the `=` operator.
  //
  // ```text
  // @foo = 1
  //      ~
  // ```
  //
  // `None` if instance variable assignment is a part of the multi-assignment.
  // In such case `value` is a part of the `Masgn` node.
  //
  struct LIB_RUBY_PARSER_MaybeLoc operator_l;
  // Location of the full expression
  //
  // ```text
  // @foo = 42
  // ~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Ivasgn;

// Represents required keyword argument (i.e. `foo` in `def m(foo:); end`)
//
typedef struct LIB_RUBY_PARSER_Kwarg {
  // Name of the keyword argument
  //
  struct LIB_RUBY_PARSER_StringPtr name;
  // Location of the name
  //
  // ```text
  // def foo(bar:); end
  //         ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc name_l;
  // Location of the full expression
  //
  // ```text
  // def foo(bar:); end
  //         ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Kwarg;

// Represents an explicit `begin; end` block.
//
// The reason why it's different is that only
// ```text
// begin; foo; end while cond
// ```
// is a post-while loop (same with post-until loop)
//
typedef struct LIB_RUBY_PARSER_KwBegin {
  // A list of statements
  //
  struct LIB_RUBY_PARSER_NodeList statements;
  // Location of the `begin` keyword
  //
  // ```text
  // begin; foo; end
  // ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of the `begin` keyword
  //
  // ```text
  // begin; foo; end
  //             ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the full expression
  //
  // ```text
  // begin; foo; bar
  // ~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_KwBegin;

// Represents an special argument that rejects all keyword arguments (i.e. `def m(**nil); end`)
//
typedef struct LIB_RUBY_PARSER_Kwnilarg {
  // Location of the `nil`
  //
  // ```text
  // def m(**nil); end
  //         ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc name_l;
  // Location of the `nil`
  //
  // ```text
  // def m(**nil); end
  //       ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Kwnilarg;

// Represents an optional keyword argument (i.e. `foo` in `def m(foo: 42); end`)
//
typedef struct LIB_RUBY_PARSER_Kwoptarg {
  // Name of the optional keyword argument
  //
  struct LIB_RUBY_PARSER_StringPtr name;
  // Default value of the optional keyword argument
  //
  LIB_RUBY_PARSER_Ptr_Node default_;
  // Location of the argument name
  //
  // ```text
  // def m(foo: 1); end
  //       ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc name_l;
  // Location of the argument name
  //
  // ```text
  // def m(foo: 1); end
  //       ~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Kwoptarg;

// C-compatible nullable String container
typedef struct LIB_RUBY_PARSER_MaybeStringPtr {
  uint8_t *ptr;
  size_t len;
} LIB_RUBY_PARSER_MaybeStringPtr;

// Represents a keyword rest argument (i.e. `foo` in `def m(**foo); end`)
//
typedef struct LIB_RUBY_PARSER_Kwrestarg {
  // Name of the keyword rest argument, `String("foo")` in `def m(**foo); end`.
  //
  // `None` if argument has no name (`def m(**); end`)
  //
  struct LIB_RUBY_PARSER_MaybeStringPtr name;
  // Location of the `**` operator
  //
  // ```text
  // def m(**foo); end
  //       ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the argument name
  //
  // ```text
  // def m(**foo); end
  //         ~~~
  // ```
  //
  // `None` if argument has no name (`def m(**); end`)
  //
  struct LIB_RUBY_PARSER_MaybeLoc name_l;
  // Location of the full expression
  //
  // ```text
  // def m(**foo); end
  //       ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Kwrestarg;

// Represents a keyword arguments splat (i.e. `**bar` in a call like `foo(**bar)`)
//
typedef struct LIB_RUBY_PARSER_Kwsplat {
  // Value that is converted into a `Hash` using `**`
  //
  LIB_RUBY_PARSER_Ptr_Node value;
  // Location of the `**` operator
  //
  // ```text
  // foo(**bar)
  //     ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the full expression
  //
  // ```text
  // foo(**bar)
  //     ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Kwsplat;

// Represents a lambda call using `->` (i.e. `-> {}`)
//
// Note that `Lambda` is a part of the `Block`, not other way around.
//
typedef struct LIB_RUBY_PARSER_Lambda {
  // Location of the `->`
  //
  // ```text
  // -> {}
  // ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Lambda;

// Represents a special `__LINE__` literal
//
typedef struct LIB_RUBY_PARSER_Line {
  // Location of the `__LINE__` literal
  //
  // ```text
  // __LINE__
  // ~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Line;

// Represents access to a local variable (i.e. `foo`)
//
// Parser knows that it's a local variable because:
//     1. there was an assignment to this variable **before** accessing it
//     2. it's an argument of the current method / block
//     3. it's been implicitly declared by `MatchWithLvasgn` node
//
// Otherwise it's a method call (see `Send`)
//
typedef struct LIB_RUBY_PARSER_Lvar {
  // Name of the local variable
  //
  struct LIB_RUBY_PARSER_StringPtr name;
  // Location of the local variable
  //
  // ```text
  // foo
  // ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Lvar;

// Represents local variable assignment (i.e. `foo = 42`)
//
typedef struct LIB_RUBY_PARSER_Lvasgn {
  // Name of the local variable
  //
  struct LIB_RUBY_PARSER_StringPtr name;
  // Value that is assigned to a local variable
  //
  LIB_RUBY_PARSER_MaybePtr_Node value;
  // Location of the local variable name
  //
  // ```text
  // foo = 42
  // ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc name_l;
  // Location of the `=` operator
  //
  // ```text
  // foo = 42
  //     ~
  // ```
  //
  // `None` if local variable assignment is a part of the multi-assignment.
  // In such case `value` is a part of the `Masgn` node.
  //
  struct LIB_RUBY_PARSER_MaybeLoc operator_l;
  // Location of the full expression
  //
  // ```text
  // foo = 42
  // ~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Lvasgn;

// Represents mass-assignment (i.e. `foo, bar = 1, 2`)
//
typedef struct LIB_RUBY_PARSER_Masgn {
  // Left hand statement of the assignment
  //
  LIB_RUBY_PARSER_Ptr_Node lhs;
  // Left hand statement of the assignment
  //
  LIB_RUBY_PARSER_Ptr_Node rhs;
  // Location of the `=` operator
  //
  // ```text
  // foo, bar = 1, 2
  //          ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the full expression
  //
  // ```text
  // foo, bar = 1, 2
  // ~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Masgn;

// Represents pattern matching using one of the given patterns (i.e. `foo in 1 | 2`)
//
typedef struct LIB_RUBY_PARSER_MatchAlt {
  // Left pattern
  //
  LIB_RUBY_PARSER_Ptr_Node lhs;
  // Right pattern
  //
  LIB_RUBY_PARSER_Ptr_Node rhs;
  // Location of the `|` operator
  //
  // ```text
  // foo in 1 | 2
  //          ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the full expression
  //
  // ```text
  // foo in 1 | 2
  //        ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_MatchAlt;

// Represents matching with renaming into specified local variable (i.e. `case 1; in Integer => a; end`)
//
typedef struct LIB_RUBY_PARSER_MatchAs {
  // Pattern that is used for matching
  //
  LIB_RUBY_PARSER_Ptr_Node value;
  // Variable that is assigned if matched (see `MatchVar` node)
  //
  LIB_RUBY_PARSER_Ptr_Node as_;
  // Location of the `=>` operator
  //
  // ```text
  // case 1; in Integer => a; end
  //                    ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the `=>` operator
  //
  // ```text
  // case 1; in Integer => a; end
  //            ~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_MatchAs;

// Represents implicit matching using `if /regex/`
//
// ```text
// if /.*/
//   puts 'true'
// else
//   puts 'false'
// end
// ```
// Prints "false".
//
// Under the hood this construction matches regex against `$_`, so the following works:
// ```text
// $_ = 'match_me'
// if /match_me/
//   puts 'true'
// else
//   puts 'false'
// end
// ```
// this code prints "true".
//
typedef struct LIB_RUBY_PARSER_MatchCurrentLine {
  // Given regex
  //
  LIB_RUBY_PARSER_Ptr_Node re;
  // Location of the regex
  //
  // ```text
  // if /re/; end
  //    ~~~~
  // ```
  //
  // Technically this location is redundant, but keeping it is the only way to
  // have the same interface for all nodes.
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_MatchCurrentLine;

// Represents empty hash pattern that is used in pattern matching (i.e. `in **nil`)
//
typedef struct LIB_RUBY_PARSER_MatchNilPattern {
  // Location of the `**` operator
  //
  // ```text
  // in **nil
  //    ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the name
  //
  // ```text
  // in **nil
  //      ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc name_l;
  // Location of the full expression
  //
  // ```text
  // in **nil
  //    ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_MatchNilPattern;

// Represents a wildcard pattern used in pattern matching (i.e. `in *foo`)
//
typedef struct LIB_RUBY_PARSER_MatchRest {
  // Name of the variable name
  //
  // `None` if there's no name (i.e. `in *`)
  //
  LIB_RUBY_PARSER_MaybePtr_Node name;
  // Location of the `*` operator
  //
  // ```text
  // case foo; in *bar; end
  //              ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the `*` operator
  //
  // ```text
  // case foo; in *bar; end
  //              ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_MatchRest;

// Represents matching with assignment into a local variable (i.e. `pattern => var`)
//
typedef struct LIB_RUBY_PARSER_MatchVar {
  // Name of the variable that is assigned if matching succeeds
  //
  struct LIB_RUBY_PARSER_StringPtr name;
  // Location of the name
  //
  // ```text
  // case foo; in pattern => bar; end
  //                         ~~~
  // ```
  //
  // **Note** it can also be produced by a hash pattern
  //
  // ```text
  // case foo; in { a: }; end
  //                ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc name_l;
  // Location of the full expression
  //
  // ```text
  // case foo; in pattern => bar; end
  //                         ~~~
  // ```
  //
  // **Note** it can also be produced by a hash pattern
  //
  // ```text
  // case foo; in { a: }; end
  //                ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_MatchVar;

// Represents matching a regex that produces local variables (i.e. `/(?<match>bar)/ =~ 'bar'`)
//
// Each named group in regex declares a local variable.
//
typedef struct LIB_RUBY_PARSER_MatchWithLvasgn {
  // Regex that is used for matching
  //
  LIB_RUBY_PARSER_Ptr_Node re;
  // Value that is used for matching
  //
  LIB_RUBY_PARSER_Ptr_Node value;
  // Location of the `=~` operatir
  //
  // ```text
  // /(?<match>bar)/ =~ 'bar'
  //                 ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the full expression
  //
  // ```text
  // /(?<match>bar)/ =~ 'bar'
  // ~~~~~~~~~~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_MatchWithLvasgn;

// Represents left hand statement of the mass-assignment (i.e. `foo, bar` in `foo, bar = 1, 2`)
//
typedef struct LIB_RUBY_PARSER_Mlhs {
  // A list of items that are assigned
  //
  struct LIB_RUBY_PARSER_NodeList items;
  // Location of the open parenthesis
  //
  // ```text
  // (a, b) = 1, 2
  // ~
  // ```
  //
  // `None` if there are no parentheses
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of the closing parenthesis
  //
  // ```text
  // (a, b) = 1, 2
  //      ~
  // ```
  //
  // `None` if there are no parentheses
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the full expression
  //
  // ```text
  // (a, b) = 1, 2
  // ~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Mlhs;

// Represents module declaration using `module` keyword
//
typedef struct LIB_RUBY_PARSER_Module {
  // Name of the module
  //
  LIB_RUBY_PARSER_Ptr_Node name;
  // Body of the module
  //
  // `None` if module has no body
  //
  LIB_RUBY_PARSER_MaybePtr_Node body;
  // Location of the `module` keyword
  //
  // ```text
  // module M; end
  // ~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the `end` keyword
  //
  // ```text
  // module M; end
  //           ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc end_l;
  // Location of the full expression
  //
  // ```text
  // module M; end
  // ~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Module;

// Represents `next` keyword
//
typedef struct LIB_RUBY_PARSER_Next {
  // Arguments given to `next`
  //
  struct LIB_RUBY_PARSER_NodeList args;
  // Location of the `next` keyword
  //
  // ```text
  // next 42
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the full expression
  //
  // ```text
  // next(42)
  // ~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Next;

// Represents `nil` literal
//
typedef struct LIB_RUBY_PARSER_Nil {
  // Location of the `nil` keyword
  //
  // ```text
  // nil
  // ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Nil;

// Represents numeric global variable (e.g. `$1`)
//
typedef struct LIB_RUBY_PARSER_NthRef {
  // Name of the variable, `String("1")` for `$1`
  //
  struct LIB_RUBY_PARSER_StringPtr name;
  // Location of the full expression
  //
  // ```text
  // $1
  // ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_NthRef;

// Represents a block that takes numbered parameters (i.e. `proc { _1 }`)
//
typedef struct LIB_RUBY_PARSER_Numblock {
  // Method call that takes a block
  //
  LIB_RUBY_PARSER_Ptr_Node call;
  // Number of parameters that block takes
  //
  uint8_t numargs;
  // Block body
  //
  LIB_RUBY_PARSER_Ptr_Node body;
  // Location of the open brace
  //
  // ```text
  // proc { _1 }
  //      ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc begin_l;
  // Location of the closing brace
  //
  // ```text
  // proc { _1 }
  //           ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc end_l;
  // Location of the open brace
  //
  // ```text
  // proc { _1 }
  // ~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Numblock;

// Represents an operation with assignment (e.g. `a += 1`)
//
typedef struct LIB_RUBY_PARSER_OpAsgn {
  // Left hand statement of the assignment
  //
  LIB_RUBY_PARSER_Ptr_Node recv;
  // Operator, can be one of:
  //     1. `+=`
  //     2. `-=`
  //     3. `*=`
  //     4. `/=`
  //     5. `|=`
  //     6. `&=`
  //     7. `>>=`
  //     8. `<<=`
  //     9. `%=`
  //     10. `^=`
  //     11. `**=`
  //
  struct LIB_RUBY_PARSER_StringPtr operator_;
  // Right hand statement of the assignment
  //
  LIB_RUBY_PARSER_Ptr_Node value;
  // Location of the operator
  //
  // ```text
  // a.b <<= c
  //     ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the operator
  //
  // ```text
  // a.b <<= c
  // ~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_OpAsgn;

// Represents optional positional argument (i.e. `foo` in `m(foo = 1)`)
//
typedef struct LIB_RUBY_PARSER_Optarg {
  // Name of the argument
  //
  struct LIB_RUBY_PARSER_StringPtr name;
  // Default value of the argument
  //
  LIB_RUBY_PARSER_Ptr_Node default_;
  // Location of the argument name
  //
  // ```text
  // def m(foo = 1); end
  //       ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc name_l;
  // Location of the `=` operator
  //
  // ```text
  // def m(foo = 1); end
  //           ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the full expression
  //
  // ```text
  // def m(foo = 1); end
  //       ~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Optarg;

// Represents `foo || bar` (or `foo or bar`) statement.
//
typedef struct LIB_RUBY_PARSER_Or {
  // Left hand statement
  //
  LIB_RUBY_PARSER_Ptr_Node lhs;
  // Right hand statement
  //
  LIB_RUBY_PARSER_Ptr_Node rhs;
  // Location of the `||`/`or` operator
  //
  // ```text
  // foo || bar
  //     ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the full expression
  //
  // ```text
  // foo || bar
  // ~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Or;

// Represents `lhs ||= rhs` assignment
//
typedef struct LIB_RUBY_PARSER_OrAsgn {
  // Left hand statement
  //
  LIB_RUBY_PARSER_Ptr_Node recv;
  // Right hand statement
  //
  LIB_RUBY_PARSER_Ptr_Node value;
  // Location of the `||=` operator
  //
  // ```text
  // foo ||= bar
  //     ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the full expression
  //
  // ```text
  // foo ||= bar
  // ~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_OrAsgn;

// Represents a key/value pair (e.g. a part of the `Hash` node)
//
typedef struct LIB_RUBY_PARSER_Pair {
  // Key of the pair
  //
  LIB_RUBY_PARSER_Ptr_Node key;
  // Value of the pair
  //
  LIB_RUBY_PARSER_Ptr_Node value;
  // Location of the `:` or `=>` operator
  //
  // ```text
  // { foo: bar }
  //      ~
  //
  // { :foo => bar }
  //        ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the full expression
  //
  // ```text
  // { foo: bar }
  //   ~~~~~~~~
  //
  // { :foo => bar }
  //   ~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Pair;

// Represents a pattern based on a "pinned" variable (e.g. `^foo`)
//
typedef struct LIB_RUBY_PARSER_Pin {
  // Variable that is pinned
  //
  LIB_RUBY_PARSER_Ptr_Node var;
  // Location of the `^` operator
  //
  // ```text
  // case foo; in ^bar; end
  //              ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc selector_l;
  // Location of the full expression
  //
  // ```text
  // case foo; in ^bar; end
  //              ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Pin;

// Represents `END { .. }` statement
//
typedef struct LIB_RUBY_PARSER_Postexe {
  // Body of the block
  //
  LIB_RUBY_PARSER_MaybePtr_Node body;
  // Location of the `END` keyword
  //
  // ```text
  // END { 42 }
  // ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the open parenthesis
  //
  // ```text
  // END { 42 }
  //     ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc begin_l;
  // Location of the closing parenthesis
  //
  // ```text
  // END { 42 }
  //          ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc end_l;
  // Location of the full expression
  //
  // ```text
  // END { 42 }
  // ~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Postexe;

// Represents `BEGIN { ... }` statement
//
typedef struct LIB_RUBY_PARSER_Preexe {
  // Body of the block
  //
  LIB_RUBY_PARSER_MaybePtr_Node body;
  // Location of the `BEGIN` keyword
  //
  // ```text
  // BEGIN { 42 }
  // ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the open parenthesis
  //
  // ```text
  // BEGIN { 42 }
  //       ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc begin_l;
  // Location of the closing parenthesis
  //
  // ```text
  // BEGIN { 42 }
  //            ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc end_l;
  // Location of the full expression
  //
  // ```text
  // BEGIN { 42 }
  // ~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Preexe;

// Represents a sole block argument (e.g. `|foo|`)
//
// Block that takes a single array argument automatically expands it.
// Adding trailing comma after block argument disables this behavior (and then the only argument is emitted as `Arg`).
//
typedef struct LIB_RUBY_PARSER_Procarg0 {
  // Parts of the sole block argument.
  //
  // `proc { |(a, b)| }` also counts as a sole argument, so this list may contain:
  //     1. A single `Arg` node (for `proc { |a| }` case)
  //     2. Multiple `Arg` nodes  (for `proc { |(a, b, c)| }` case)
  //
  struct LIB_RUBY_PARSER_NodeList args;
  // Location of the open parenthesis
  //
  // ```text
  // proc { |(foo, bar)| }
  //         ~
  // ```
  //
  // `None` if there's only one argument
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of the open parenthesis
  //
  // ```text
  // proc { |(foo, bar)| }
  //                  ~
  // ```
  //
  // `None` if there's only one argument
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the full expression
  //
  // ```text
  // proc { |(foo, bar)| }
  //         ~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Procarg0;

// Represents rational literal (e.g. `1r`)
//
typedef struct LIB_RUBY_PARSER_Rational {
  // String value of the literal, `String("1r")` for `1r`
  //
  struct LIB_RUBY_PARSER_StringPtr value;
  // Location of the unary `-` (but not `+`)
  //
  // ```text
  // -1r
  // ~
  // ```
  //
  struct LIB_RUBY_PARSER_MaybeLoc operator_l;
  // Location of the full expression
  //
  // ```text
  // -1r
  // ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Rational;

// Represents `redo` keyword
//
typedef struct LIB_RUBY_PARSER_Redo {
  // Location of the full expression
  //
  // ```text
  // redo
  // ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Redo;

// Represents flags of the regex literal (i.e. `mix` for `/foo/mix`)
//
typedef struct LIB_RUBY_PARSER_RegOpt {
  // A list of flags
  //
  struct LIB_RUBY_PARSER_MaybeStringPtr options;
  // Location of the full expression
  //
  // ```text
  // /foo/mix
  //      ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_RegOpt;

// Represents regex literal (e.g. `/foo/`)
//
typedef struct LIB_RUBY_PARSER_Regexp {
  // A list of static and dynamic regex parts
  //
  struct LIB_RUBY_PARSER_NodeList parts;
  // Regex options.
  //
  // `None` if regex has no explicit flags
  //
  LIB_RUBY_PARSER_MaybePtr_Node options;
  // Location of the regex begin
  //
  // ```text
  // /foo/
  // ~
  //
  // %r{foo}
  // ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc begin_l;
  // Location of the regex end
  //
  // ```text
  // /foo/
  //     ~
  //
  // %r{foo}
  //       ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc end_l;
  // Location of the full expression
  //
  // ```text
  // /foo/mix
  // ~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Regexp;

// Represents a `rescue` block
//
typedef struct LIB_RUBY_PARSER_Rescue {
  // Body of the block that is wrapped into `rescue` (i.e. the part that may throw an error)
  //
  LIB_RUBY_PARSER_MaybePtr_Node body;
  // A list of `rescue` handlers (see `RescueBody` node)
  //
  struct LIB_RUBY_PARSER_NodeList rescue_bodies;
  // Else branch.
  //
  // `None` if there's no `else` branch
  //
  LIB_RUBY_PARSER_MaybePtr_Node else_;
  // Location of the `else` keyword
  //
  // ```text
  // begin; 1; rescue StandardError => e; 2; else; 3; end
  //                                         ~~~~
  // ```
  //
  // `None` if there's no `else` branch
  //
  struct LIB_RUBY_PARSER_MaybeLoc else_l;
  // Location of the full expression
  //
  // ```text
  // begin; 1; rescue StandardError => e; 2; else; 3; end
  //        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  // ```
  //
  // **Note**: `begin/end` keywords belong to `KwBegin` node
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Rescue;

// Represents a single `rescue` handler (i.e. `rescue E => e ...`)
//
typedef struct LIB_RUBY_PARSER_RescueBody {
  // A list of exception classes
  //
  // `None` if no classes specified (i.e. `rescue => e; ...` or just `rescue; ...`)
  //
  LIB_RUBY_PARSER_MaybePtr_Node exc_list;
  // Variable that captures exception
  //
  // `None` if no variable specified (i.e. `rescue E; ...` or just `rescue; ... `)
  //
  LIB_RUBY_PARSER_MaybePtr_Node exc_var;
  // Body of the handler
  //
  LIB_RUBY_PARSER_MaybePtr_Node body;
  // Location of the `rescue` keyword
  //
  // ```text
  // begin; 1; rescue E => e; 2; end
  //           ~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the `=>` operator
  //
  // ```text
  // begin; 1; rescue E => e; 2; end
  //                    ~~
  // ```
  //
  // `None` if exception is not captured.
  //
  struct LIB_RUBY_PARSER_MaybeLoc assoc_l;
  // Location of the `then` keyword
  //
  // ```text
  // begin; 1; rescue E => e then; 2; end
  //                         ~~~~
  // ```
  //
  // `then` is optional, so `begin_l` can be `None`
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of the full expression
  //
  // ```text
  // begin; 1; rescue E => e then; 2; end
  //           ~~~~~~~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_RescueBody;

// Represents positional rest argument (i.e. `*foo` in `def m(*foo); end`)
//
typedef struct LIB_RUBY_PARSER_Restarg {
  // Name of the argument.
  //
  // `None` if argument has no name (i.e. `def m(*); end`)
  //
  struct LIB_RUBY_PARSER_MaybeStringPtr name;
  // Location of the `*` operator
  //
  // ```text
  // def m(*foo); end
  //       ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the argument name
  //
  // ```text
  // def m(*foo); end
  //        ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_MaybeLoc name_l;
  // Location of the full expression
  //
  // ```text
  // def m(*foo); end
  //       ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Restarg;

// Represents `retry` keyword
//
typedef struct LIB_RUBY_PARSER_Retry {
  // Location of the `retry` keyword
  //
  // ```text
  // retry
  // ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Retry;

// Represents `return` keyword
//
typedef struct LIB_RUBY_PARSER_Return {
  // A list of values that is returned
  //
  struct LIB_RUBY_PARSER_NodeList args;
  // Location of the `return` keyword
  //
  // ```text
  // return 1, 2
  // ~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the full expression
  //
  // ```text
  // return 1, 2
  // ~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Return;

// Represents opening a singleton class (i.e. `class << foo; ... end;`)
//
typedef struct LIB_RUBY_PARSER_SClass {
  // Expression that is used to get a singleton class
  //
  // `Lvar("foo")` for `class << foo; end`
  //
  LIB_RUBY_PARSER_Ptr_Node expr;
  // Body of the block
  //
  LIB_RUBY_PARSER_MaybePtr_Node body;
  // Location of the `class` keyword
  //
  // ```text
  // class << foo; end
  // ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the `<<` operator
  //
  // ```text
  // class << foo; end
  //       ~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the `end` keyword
  //
  // ```text
  // class << foo; end
  //               ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc end_l;
  // Location of the full expression
  //
  // ```text
  // class << foo; end
  // ~~~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_SClass;

// Represents `self` keyword
//
typedef struct LIB_RUBY_PARSER_Self_ {
  // Location of the `self` keyword
  //
  // ```text
  // self
  // ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Self_;

// Represents a method call (e.g. `foo.bar(42)`)
//
typedef struct LIB_RUBY_PARSER_Send {
  // Receiver of the method call
  //
  // `None` for implicit method call (e.g. `foo(42)`)
  //
  LIB_RUBY_PARSER_MaybePtr_Node recv;
  // Name of the method that is called
  //
  struct LIB_RUBY_PARSER_StringPtr method_name;
  // A list of arguments
  //
  struct LIB_RUBY_PARSER_NodeList args;
  // Location of the `.` operator
  //
  // ```text
  // foo.bar(42)
  //    ~
  // ```
  //
  // `None` for implicit method call (e.g. `foo(42)`)
  //
  struct LIB_RUBY_PARSER_MaybeLoc dot_l;
  // Location of the method name
  //
  // ```text
  // foo.bar(42)
  //     ~~~
  // ```
  //
  // `None` in a very special case when method call is implicit (i.e. `foo.(42)`)
  //
  struct LIB_RUBY_PARSER_MaybeLoc selector_l;
  // Location of open parenthesis
  //
  // ```text
  // foo(42)
  //    ~
  // ```
  //
  // `None` if there are parentheses
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of closing parenthesis
  //
  // ```text
  // foo(42)
  //       ~
  // ```
  //
  // `None` if there are parentheses
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the operator if method is a setter
  //
  // ```text
  // foo.bar = 42
  //         ~
  // ```
  //
  // `None` otherwise
  //
  struct LIB_RUBY_PARSER_MaybeLoc operator_l;
  // Location of the full expression
  //
  // ```text
  // foo.bar(42)
  // ~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Send;

// Represents a special block argument that "shadows" outer variable (i.e. `|;foo|`)
//
typedef struct LIB_RUBY_PARSER_Shadowarg {
  // Name of the argument
  //
  struct LIB_RUBY_PARSER_StringPtr name;
  // Location of the argument
  //
  // ```text
  // proc { |;foo|}
  //          ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Shadowarg;

// Represents an arguments splat (i.e. `*bar` in a call like `foo(*bar)`)
//
typedef struct LIB_RUBY_PARSER_Splat {
  // Value that is converted to array
  //
  LIB_RUBY_PARSER_MaybePtr_Node value;
  // Location of the `*` operator
  //
  // ```text
  // foo(*bar)
  //     ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc operator_l;
  // Location of the full expression
  //
  // ```text
  // foo(*bar)
  //     ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Splat;

// Represents a plain non-interpolated string literal (e.g. `"foo"`)
//
typedef struct LIB_RUBY_PARSER_Str {
  // Value of the string literal
  //
  // Note that it's a `StringValue`, not a `String`.
  // The reason is that you can get UTF-8 incompatible strings
  // from a valid UTF-8 source using escape sequences like `"\xFF"`
  //
  // These "\", "x", "F", "F" chars are valid separately, but together
  // they construct a char with code = 255 that is invalid for UTF-8.
  //
  // You can use `to_string_lossy` or `to_string` methods to get a raw string value.
  //
  struct LIB_RUBY_PARSER_StringValue value;
  // Location of the string begin
  //
  // ```text
  // "foo"
  // ~
  // ```
  //
  // `None` if string literal is a part of the words array (like `%w[foo bar baz]`)
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of the string begin
  //
  // ```text
  // "foo"
  //     ~
  // ```
  //
  // `None` if string literal is a part of the words array (like `%w[foo bar baz]`)
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the full expression
  //
  // ```text
  // "foo"
  // ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Str;

// Represents a `super` keyword
//
typedef struct LIB_RUBY_PARSER_Super {
  // A list of arguments given to `super`
  //
  struct LIB_RUBY_PARSER_NodeList args;
  // Location of the `super` keyword
  //
  // ```text
  // super(1, 2)
  // ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the open parenthesis
  //
  // ```text
  // super(1, 2)
  //      ~
  // ```
  //
  // `None` if there are no parentheses
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of the closing parenthesis
  //
  // ```text
  // super(1, 2)
  //           ~
  // ```
  //
  // `None` if there are no parentheses
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the full expression
  //
  // ```text
  // super(1, 2)
  // ~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Super;

// Represents a plain symbol literal (i.e. `:foo`)
//
// Note that `:` in `{ foo: bar }` belongs to a `pair` node.
//
typedef struct LIB_RUBY_PARSER_Sym {
  // Value of the symbol literal
  //
  // Note that it's a `StringValue`, not a `String`.
  // The reason is that you can get UTF-8 incompatible strings
  // from a valid UTF-8 source using escape sequences like `"\xFF"`
  //
  // These "\", "x", "F", "F" chars are valid separately, but together
  // they construct a char with code = 255 that is invalid for UTF-8.
  //
  // You can use `to_string_lossy` or `to_string` methods to get a raw symbol value.
  //
  struct LIB_RUBY_PARSER_StringValue name;
  // Location of the symbol begin
  //
  // ```text
  // :foo
  // ~
  // ```
  //
  // `None` if symbol is a label (`{ foo: 1 }`) or a part of the symbols array (`%i[foo bar baz]`)
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of the symbol end
  //
  // ```text
  // { 'foo': 1 }
  //        ~
  // ```
  //
  // `None` if symbol is **not** a string label (`:foo`) or a part of the symbols array (`%i[foo bar baz]`)
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the full expression
  //
  // ```text
  // :foo
  // ~~~~
  //
  // { foo: 1 }
  //   ~~~~
  //
  // %i[foo]
  //    ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Sym;

// Represents a `true` literal
//
typedef struct LIB_RUBY_PARSER_True {
  // Location of the `true` keyword
  //
  // ```text
  // true
  // ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_True;

// Represents an `undef` keyword (e.g. `undef foo, :bar`)
//
typedef struct LIB_RUBY_PARSER_Undef {
  // A list of names to `undef`
  //
  struct LIB_RUBY_PARSER_NodeList names;
  // Location the `undef` keyword
  //
  // ```text
  // undef foo, :bar
  // ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the full expression
  //
  // ```text
  // undef :foo, bar
  // ~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Undef;

// Represents an `unless` guard used in pattern matching (i.e. `in pattern unless guard`)
//
typedef struct LIB_RUBY_PARSER_UnlessGuard {
  // Condition of the guard, `Lvar("foo")` in `in pattern unless guard`
  //
  LIB_RUBY_PARSER_Ptr_Node cond;
  // Location of the `unless` keyword
  //
  // ```text
  // case foo; in pattern unless cond; end
  //                      ~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the full expression
  //
  // ```text
  // case foo; in pattern unless cond; end
  //                      ~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_UnlessGuard;

// Represents `until` loop
//
typedef struct LIB_RUBY_PARSER_Until {
  // Condition of the loop
  //
  LIB_RUBY_PARSER_Ptr_Node cond;
  // Body of the loop.
  //
  // `None` if body is empty
  //
  LIB_RUBY_PARSER_MaybePtr_Node body;
  // Location of the `until` keyword
  //
  // ```text
  // until cond do; foo; end
  // ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the `do` keyword
  //
  // ```text
  // until cond do; foo; end
  //            ~~
  // ```
  //
  // `do` is optional, and so `begin_l` can be `None`
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of the `end` keyword
  //
  // ```text
  // until cond do; foo; end
  //                     ~~~
  // ```
  //
  // `None` if loop is a modifier (i.e. `foo until bar`)
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the full expression
  //
  // ```text
  // until cond do; foo; end
  // ~~~~~~~~~~~~~~~~~~~~~~~
  //
  // foo until bar
  // ~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Until;

// Represents a post-until loop
//
// ```text
// begin
//   foo
// end until bar
// ```
//
typedef struct LIB_RUBY_PARSER_UntilPost {
  // Condition of the loop
  //
  LIB_RUBY_PARSER_Ptr_Node cond;
  // Body of the loop
  //
  LIB_RUBY_PARSER_Ptr_Node body;
  // Location of the `until` keyword
  //
  // ```text
  // begin; foo; end until bar
  //                 ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the `until` keyword
  //
  // ```text
  // begin; foo; end until bar
  // ~~~~~~~~~~~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_UntilPost;

// Represents a branch of the `case` statement (i.e. `when foo`)
//
typedef struct LIB_RUBY_PARSER_When {
  // A list of values to compare/match against
  //
  struct LIB_RUBY_PARSER_NodeList patterns;
  // Body of the `when` branch
  //
  LIB_RUBY_PARSER_MaybePtr_Node body;
  // Location of the `when` keyword
  //
  // ```text
  // case foo; when bar; end
  //           ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the `then` keyword
  //
  // ```text
  // case foo; when bar then baz; end
  //                    ~~~~
  // ```
  //
  // `then` is optional, and so `begin_l` can be `None`
  //
  struct LIB_RUBY_PARSER_Loc begin_l;
  // Location of the full expression
  //
  // ```text
  // case foo; when bar then baz; end
  //           ~~~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_When;

// Represents `while` loop
//
typedef struct LIB_RUBY_PARSER_While {
  // Condition of the loop
  //
  LIB_RUBY_PARSER_Ptr_Node cond;
  // Body of the loop.
  //
  // `None` if body is empty
  //
  LIB_RUBY_PARSER_MaybePtr_Node body;
  // Location of the `while` keyword
  //
  // ```text
  // while cond do; foo; end
  // ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the `do` keyword
  //
  // ```text
  // while cond do; foo; end
  //            ~~
  // ```
  //
  // `do` is optional, and so `begin_l` can be `None`
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of the `end` keyword
  //
  // ```text
  // while cond do; foo; end
  //                     ~~~
  // ```
  //
  // `None` if loop is a modifier (i.e. `foo while bar`)
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the full expression
  //
  // ```text
  // while cond do; foo; end
  // ~~~~~~~~~~~~~~~~~~~~~~~
  //
  // foo while bar
  // ~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_While;

// Represents a post-while loop
//
// ```text
// begin
//   foo
// end while bar
// ```
//
typedef struct LIB_RUBY_PARSER_WhilePost {
  // Condition of the loop
  //
  LIB_RUBY_PARSER_Ptr_Node cond;
  // Body of the loop
  //
  LIB_RUBY_PARSER_Ptr_Node body;
  // Location of the `while` keyword
  //
  // ```text
  // begin; foo; end while bar
  //                 ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the `while` keyword
  //
  // ```text
  // begin; foo; end while bar
  // ~~~~~~~~~~~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_WhilePost;

// Represents a executable here-document literal (both with and without interpolation)
//
// It's similar to `Xstr` in terms of abstract syntax tree, but has different source maps.
//
typedef struct LIB_RUBY_PARSER_XHeredoc {
  // A list of string parts (static literals and interpolated expressions)
  //
  struct LIB_RUBY_PARSER_NodeList parts;
  // Location of the executable here-document body
  //
  // ```text
  // <<-`HERE`\n  a\n   #{42}\nHERE
  //          ~~~~~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc heredoc_body_l;
  // Location of the executable here-document end
  //
  // ```text
  // <<-`HERE`\n  a\n   #{42}\nHERE
  //                         ~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc heredoc_end_l;
  // Location of the executable here-document identifier
  //
  // ```text
  // <<-`HERE`\n  a\n   #{42}\nHERE
  // ~~~~~~~
  // ```
  //
  // **Note**: This is the only node (with `Heredoc`) that has `expression_l` smaller that all other sub-locations merged.
  // The reason for that is that it's possible to add more code after here-document ID:
  //
  // ```text
  // <<-`HERE` + "rest"
  //   content
  // HERE
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_XHeredoc;

// Represents an executable string (i.e. `` `sh #{script_name}` ``)
//
typedef struct LIB_RUBY_PARSER_Xstr {
  // A list of string parts (static literals and interpolated expressions)
  //
  struct LIB_RUBY_PARSER_NodeList parts;
  // Location of the string begin
  //
  // ```text
  // `#{foo}`
  // ~
  //
  // %X{#{foo}}
  // ~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc begin_l;
  // Location of the string end
  //
  // ```text
  // `#{foo}`
  //        ~
  //
  // %X{#{foo}}
  //          ~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc end_l;
  // Location of the full expression
  //
  // ```text
  // `#{foo}`
  // ~~~~~~~~
  //
  // %X{#{foo}}
  // ~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Xstr;

// Represents an `yield` keyword
//
typedef struct LIB_RUBY_PARSER_Yield {
  // A list of arguments given to `yield`
  //
  struct LIB_RUBY_PARSER_NodeList args;
  // Location of the `yield` keyword
  //
  // ```text
  // yield 1, 2
  // ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc keyword_l;
  // Location of the open parenthesis
  //
  // ```text
  // yield(1, 2)
  //      ~
  // ```
  //
  // `None` if there are no parentheses
  //
  struct LIB_RUBY_PARSER_MaybeLoc begin_l;
  // Location of the closing parenthesis
  //
  // ```text
  // yield(1, 2)
  //           ~
  // ```
  //
  // `None` if there are no parentheses
  //
  struct LIB_RUBY_PARSER_MaybeLoc end_l;
  // Location of the full expression
  //
  // ```text
  // yield(1, 2)
  // ~~~~~~~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_Yield;

// Represents a `super` call without arguments and parentheses
//
// It's different from `super()` as it implicitly forwards current arguments
//
typedef struct LIB_RUBY_PARSER_ZSuper {
  // Location of the `super` keyword
  //
  // ```text
  // super
  // ~~~~~
  // ```
  //
  struct LIB_RUBY_PARSER_Loc expression_l;
} LIB_RUBY_PARSER_ZSuper;

// Generic combination of all known nodes.
typedef enum LIB_RUBY_PARSER_Node_Tag {
  NODE_ALIAS,
  NODE_AND_ASGN,
  NODE_AND,
  NODE_ARG,
  NODE_ARGS,
  NODE_ARRAY,
  NODE_ARRAY_PATTERN,
  NODE_ARRAY_PATTERN_WITH_TAIL,
  NODE_BACK_REF,
  NODE_BEGIN,
  NODE_BLOCK,
  NODE_BLOCK_PASS,
  NODE_BLOCKARG,
  NODE_BREAK,
  NODE_CASE,
  NODE_CASE_MATCH,
  NODE_CASGN,
  NODE_CBASE,
  NODE_CLASS,
  NODE_COMPLEX,
  NODE_CONST,
  NODE_CONST_PATTERN,
  NODE_C_SEND,
  NODE_CVAR,
  NODE_CVASGN,
  NODE_DEF,
  NODE_DEFINED,
  NODE_DEFS,
  NODE_DSTR,
  NODE_DSYM,
  NODE_E_FLIP_FLOP,
  NODE_EMPTY_ELSE,
  NODE_ENCODING,
  NODE_ENSURE,
  NODE_ERANGE,
  NODE_FALSE,
  NODE_FILE,
  NODE_FIND_PATTERN,
  NODE_FLOAT,
  NODE_FOR,
  NODE_FORWARD_ARG,
  NODE_FORWARDED_ARGS,
  NODE_GVAR,
  NODE_GVASGN,
  NODE_HASH,
  NODE_KWARGS,
  NODE_HASH_PATTERN,
  NODE_HEREDOC,
  NODE_IF,
  NODE_IF_GUARD,
  NODE_IF_MOD,
  NODE_IF_TERNARY,
  NODE_I_FLIP_FLOP,
  NODE_MATCH_PATTERN,
  NODE_MATCH_PATTERN_P,
  NODE_IN_PATTERN,
  NODE_INDEX,
  NODE_INDEX_ASGN,
  NODE_INT,
  NODE_IRANGE,
  NODE_IVAR,
  NODE_IVASGN,
  NODE_KWARG,
  NODE_KW_BEGIN,
  NODE_KWNILARG,
  NODE_KWOPTARG,
  NODE_KWRESTARG,
  NODE_KWSPLAT,
  NODE_LAMBDA,
  NODE_LINE,
  NODE_LVAR,
  NODE_LVASGN,
  NODE_MASGN,
  NODE_MATCH_ALT,
  NODE_MATCH_AS,
  NODE_MATCH_CURRENT_LINE,
  NODE_MATCH_NIL_PATTERN,
  NODE_MATCH_REST,
  NODE_MATCH_VAR,
  NODE_MATCH_WITH_LVASGN,
  NODE_MLHS,
  NODE_MODULE,
  NODE_NEXT,
  NODE_NIL,
  NODE_NTH_REF,
  NODE_NUMBLOCK,
  NODE_OP_ASGN,
  NODE_OPTARG,
  NODE_OR,
  NODE_OR_ASGN,
  NODE_PAIR,
  NODE_PIN,
  NODE_POSTEXE,
  NODE_PREEXE,
  NODE_PROCARG0,
  NODE_RATIONAL,
  NODE_REDO,
  NODE_REG_OPT,
  NODE_REGEXP,
  NODE_RESCUE,
  NODE_RESCUE_BODY,
  NODE_RESTARG,
  NODE_RETRY,
  NODE_RETURN,
  NODE_S_CLASS,
  NODE_SELF,
  NODE_SEND,
  NODE_SHADOWARG,
  NODE_SPLAT,
  NODE_STR,
  NODE_SUPER,
  NODE_SYM,
  NODE_TRUE,
  NODE_UNDEF,
  NODE_UNLESS_GUARD,
  NODE_UNTIL,
  NODE_UNTIL_POST,
  NODE_WHEN,
  NODE_WHILE,
  NODE_WHILE_POST,
  NODE_X_HEREDOC,
  NODE_XSTR,
  NODE_YIELD,
  NODE_Z_SUPER,
} LIB_RUBY_PARSER_Node_Tag;

typedef struct LIB_RUBY_PARSER_Node {
  LIB_RUBY_PARSER_Node_Tag tag;
  union {
    struct {
      struct LIB_RUBY_PARSER_Alias alias;
    };
    struct {
      struct LIB_RUBY_PARSER_AndAsgn and_asgn;
    };
    struct {
      struct LIB_RUBY_PARSER_And and;
    };
    struct {
      struct LIB_RUBY_PARSER_Arg arg;
    };
    struct {
      struct LIB_RUBY_PARSER_Args args;
    };
    struct {
      struct LIB_RUBY_PARSER_Array array;
    };
    struct {
      struct LIB_RUBY_PARSER_ArrayPattern array_pattern;
    };
    struct {
      struct LIB_RUBY_PARSER_ArrayPatternWithTail array_pattern_with_tail;
    };
    struct {
      struct LIB_RUBY_PARSER_BackRef back_ref;
    };
    struct {
      struct LIB_RUBY_PARSER_Begin begin;
    };
    struct {
      struct LIB_RUBY_PARSER_Block block;
    };
    struct {
      struct LIB_RUBY_PARSER_BlockPass block_pass;
    };
    struct {
      struct LIB_RUBY_PARSER_Blockarg blockarg;
    };
    struct {
      struct LIB_RUBY_PARSER_Break break_;
    };
    struct {
      struct LIB_RUBY_PARSER_Case case_;
    };
    struct {
      struct LIB_RUBY_PARSER_CaseMatch case_match;
    };
    struct {
      struct LIB_RUBY_PARSER_Casgn casgn;
    };
    struct {
      struct LIB_RUBY_PARSER_Cbase cbase;
    };
    struct {
      struct LIB_RUBY_PARSER_Class class_;
    };
    struct {
      struct LIB_RUBY_PARSER_Complex complex;
    };
    struct {
      struct LIB_RUBY_PARSER_Const const_;
    };
    struct {
      struct LIB_RUBY_PARSER_ConstPattern const_pattern;
    };
    struct {
      struct LIB_RUBY_PARSER_CSend c_send;
    };
    struct {
      struct LIB_RUBY_PARSER_Cvar cvar;
    };
    struct {
      struct LIB_RUBY_PARSER_Cvasgn cvasgn;
    };
    struct {
      struct LIB_RUBY_PARSER_Def def;
    };
    struct {
      struct LIB_RUBY_PARSER_Defined defined;
    };
    struct {
      struct LIB_RUBY_PARSER_Defs defs;
    };
    struct {
      struct LIB_RUBY_PARSER_Dstr dstr;
    };
    struct {
      struct LIB_RUBY_PARSER_Dsym dsym;
    };
    struct {
      struct LIB_RUBY_PARSER_EFlipFlop e_flip_flop;
    };
    struct {
      struct LIB_RUBY_PARSER_EmptyElse empty_else;
    };
    struct {
      struct LIB_RUBY_PARSER_Encoding encoding;
    };
    struct {
      struct LIB_RUBY_PARSER_Ensure ensure;
    };
    struct {
      struct LIB_RUBY_PARSER_Erange erange;
    };
    struct {
      struct LIB_RUBY_PARSER_False false_;
    };
    struct {
      struct LIB_RUBY_PARSER_File file;
    };
    struct {
      struct LIB_RUBY_PARSER_FindPattern find_pattern;
    };
    struct {
      struct LIB_RUBY_PARSER_Float float_;
    };
    struct {
      struct LIB_RUBY_PARSER_For for_;
    };
    struct {
      struct LIB_RUBY_PARSER_ForwardArg forward_arg;
    };
    struct {
      struct LIB_RUBY_PARSER_ForwardedArgs forwarded_args;
    };
    struct {
      struct LIB_RUBY_PARSER_Gvar gvar;
    };
    struct {
      struct LIB_RUBY_PARSER_Gvasgn gvasgn;
    };
    struct {
      struct LIB_RUBY_PARSER_Hash hash;
    };
    struct {
      struct LIB_RUBY_PARSER_Kwargs kwargs;
    };
    struct {
      struct LIB_RUBY_PARSER_HashPattern hash_pattern;
    };
    struct {
      struct LIB_RUBY_PARSER_Heredoc heredoc;
    };
    struct {
      struct LIB_RUBY_PARSER_If if_;
    };
    struct {
      struct LIB_RUBY_PARSER_IfGuard if_guard;
    };
    struct {
      struct LIB_RUBY_PARSER_IfMod if_mod;
    };
    struct {
      struct LIB_RUBY_PARSER_IfTernary if_ternary;
    };
    struct {
      struct LIB_RUBY_PARSER_IFlipFlop i_flip_flop;
    };
    struct {
      struct LIB_RUBY_PARSER_MatchPattern match_pattern;
    };
    struct {
      struct LIB_RUBY_PARSER_MatchPatternP match_pattern_p;
    };
    struct {
      struct LIB_RUBY_PARSER_InPattern in_pattern;
    };
    struct {
      struct LIB_RUBY_PARSER_Index index;
    };
    struct {
      struct LIB_RUBY_PARSER_IndexAsgn index_asgn;
    };
    struct {
      struct LIB_RUBY_PARSER_Int int_;
    };
    struct {
      struct LIB_RUBY_PARSER_Irange irange;
    };
    struct {
      struct LIB_RUBY_PARSER_Ivar ivar;
    };
    struct {
      struct LIB_RUBY_PARSER_Ivasgn ivasgn;
    };
    struct {
      struct LIB_RUBY_PARSER_Kwarg kwarg;
    };
    struct {
      struct LIB_RUBY_PARSER_KwBegin kw_begin;
    };
    struct {
      struct LIB_RUBY_PARSER_Kwnilarg kwnilarg;
    };
    struct {
      struct LIB_RUBY_PARSER_Kwoptarg kwoptarg;
    };
    struct {
      struct LIB_RUBY_PARSER_Kwrestarg kwrestarg;
    };
    struct {
      struct LIB_RUBY_PARSER_Kwsplat kwsplat;
    };
    struct {
      struct LIB_RUBY_PARSER_Lambda lambda;
    };
    struct {
      struct LIB_RUBY_PARSER_Line line;
    };
    struct {
      struct LIB_RUBY_PARSER_Lvar lvar;
    };
    struct {
      struct LIB_RUBY_PARSER_Lvasgn lvasgn;
    };
    struct {
      struct LIB_RUBY_PARSER_Masgn masgn;
    };
    struct {
      struct LIB_RUBY_PARSER_MatchAlt match_alt;
    };
    struct {
      struct LIB_RUBY_PARSER_MatchAs match_as;
    };
    struct {
      struct LIB_RUBY_PARSER_MatchCurrentLine match_current_line;
    };
    struct {
      struct LIB_RUBY_PARSER_MatchNilPattern match_nil_pattern;
    };
    struct {
      struct LIB_RUBY_PARSER_MatchRest match_rest;
    };
    struct {
      struct LIB_RUBY_PARSER_MatchVar match_var;
    };
    struct {
      struct LIB_RUBY_PARSER_MatchWithLvasgn match_with_lvasgn;
    };
    struct {
      struct LIB_RUBY_PARSER_Mlhs mlhs;
    };
    struct {
      struct LIB_RUBY_PARSER_Module module;
    };
    struct {
      struct LIB_RUBY_PARSER_Next next;
    };
    struct {
      struct LIB_RUBY_PARSER_Nil nil;
    };
    struct {
      struct LIB_RUBY_PARSER_NthRef nth_ref;
    };
    struct {
      struct LIB_RUBY_PARSER_Numblock numblock;
    };
    struct {
      struct LIB_RUBY_PARSER_OpAsgn op_asgn;
    };
    struct {
      struct LIB_RUBY_PARSER_Optarg optarg;
    };
    struct {
      struct LIB_RUBY_PARSER_Or or;
    };
    struct {
      struct LIB_RUBY_PARSER_OrAsgn or_asgn;
    };
    struct {
      struct LIB_RUBY_PARSER_Pair pair;
    };
    struct {
      struct LIB_RUBY_PARSER_Pin pin;
    };
    struct {
      struct LIB_RUBY_PARSER_Postexe postexe;
    };
    struct {
      struct LIB_RUBY_PARSER_Preexe preexe;
    };
    struct {
      struct LIB_RUBY_PARSER_Procarg0 procarg0;
    };
    struct {
      struct LIB_RUBY_PARSER_Rational rational;
    };
    struct {
      struct LIB_RUBY_PARSER_Redo redo;
    };
    struct {
      struct LIB_RUBY_PARSER_RegOpt reg_opt;
    };
    struct {
      struct LIB_RUBY_PARSER_Regexp regexp;
    };
    struct {
      struct LIB_RUBY_PARSER_Rescue rescue;
    };
    struct {
      struct LIB_RUBY_PARSER_RescueBody rescue_body;
    };
    struct {
      struct LIB_RUBY_PARSER_Restarg restarg;
    };
    struct {
      struct LIB_RUBY_PARSER_Retry retry;
    };
    struct {
      struct LIB_RUBY_PARSER_Return return_;
    };
    struct {
      struct LIB_RUBY_PARSER_SClass s_class;
    };
    struct {
      struct LIB_RUBY_PARSER_Self_ self;
    };
    struct {
      struct LIB_RUBY_PARSER_Send send;
    };
    struct {
      struct LIB_RUBY_PARSER_Shadowarg shadowarg;
    };
    struct {
      struct LIB_RUBY_PARSER_Splat splat;
    };
    struct {
      struct LIB_RUBY_PARSER_Str str;
    };
    struct {
      struct LIB_RUBY_PARSER_Super super;
    };
    struct {
      struct LIB_RUBY_PARSER_Sym sym;
    };
    struct {
      struct LIB_RUBY_PARSER_True true_;
    };
    struct {
      struct LIB_RUBY_PARSER_Undef undef;
    };
    struct {
      struct LIB_RUBY_PARSER_UnlessGuard unless_guard;
    };
    struct {
      struct LIB_RUBY_PARSER_Until until;
    };
    struct {
      struct LIB_RUBY_PARSER_UntilPost until_post;
    };
    struct {
      struct LIB_RUBY_PARSER_When when;
    };
    struct {
      struct LIB_RUBY_PARSER_While while_;
    };
    struct {
      struct LIB_RUBY_PARSER_WhilePost while_post;
    };
    struct {
      struct LIB_RUBY_PARSER_XHeredoc x_heredoc;
    };
    struct {
      struct LIB_RUBY_PARSER_Xstr xstr;
    };
    struct {
      struct LIB_RUBY_PARSER_Yield yield;
    };
    struct {
      struct LIB_RUBY_PARSER_ZSuper z_super;
    };
  };
} LIB_RUBY_PARSER_Node;

// Print everything
#define LIB_RUBY_PARSER_ALL ((LIB_RUBY_PARSER_PARSER | LIB_RUBY_PARSER_LEXER) | LIB_RUBY_PARSER_BUFFER)

// Print only debug information of the Buffer
#define LIB_RUBY_PARSER_BUFFER (1 << 2)

// Print only debug information of the lexer
#define LIB_RUBY_PARSER_LEXER (1 << 1)

// Print no debug information
#define LIB_RUBY_PARSER_NONE 0

// Print only debug information of the parser
#define LIB_RUBY_PARSER_PARSER (1 << 0)

struct LIB_RUBY_PARSER_ParserOptions lib_ruby_parser_default_parser_options(void);

char *lib_ruby_parser_diagnostic_render_message(struct LIB_RUBY_PARSER_Diagnostic d);

void lib_ruby_parser_free_byte_list(struct LIB_RUBY_PARSER_ByteList list);

void lib_ruby_parser_free_parser_options(struct LIB_RUBY_PARSER_ParserOptions options);

void lib_ruby_parser_free_parser_result(struct LIB_RUBY_PARSER_ParserResult parser_result);

void lib_ruby_parser_free_string_ptr(struct LIB_RUBY_PARSER_StringPtr ptr);

char *lib_ruby_parser_inspect_parser_result(struct LIB_RUBY_PARSER_ParserResult parser_result);

uint32_t lib_ruby_parser_loc_size(struct LIB_RUBY_PARSER_Loc loc);

char *lib_ruby_parser_loc_source(struct LIB_RUBY_PARSER_Loc loc,
                                 struct LIB_RUBY_PARSER_DecodedInput input);

struct LIB_RUBY_PARSER_ByteList lib_ruby_parser_make_byte_list(const char *input);

struct LIB_RUBY_PARSER_StringPtr lib_ruby_parser_make_string_ptr(const char *input);

struct LIB_RUBY_PARSER_Loc lib_ruby_parser_maybe_loc_ptr_to_loc_ptr(struct LIB_RUBY_PARSER_MaybeLoc maybe_loc);

struct LIB_RUBY_PARSER_ParserResult lib_ruby_parser_parse(struct LIB_RUBY_PARSER_ByteList input,
                                                          struct LIB_RUBY_PARSER_ParserOptions options);

struct LIB_RUBY_PARSER_ByteList lib_ruby_parser_string_ptr_to_list(struct LIB_RUBY_PARSER_StringPtr ptr);

struct LIB_RUBY_PARSER_ByteList lib_ruby_parser_string_value_to_list(struct LIB_RUBY_PARSER_StringValue s);

char *lib_ruby_parser_token_name(int32_t token_id);

#endif /* LIB_RUBY_PARSER_C_BINDINGS_H */
