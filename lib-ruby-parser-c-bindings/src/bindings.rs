/* automatically generated by rust-bindgen */

pub type Input = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Loc {
    pub begin: u32,
    pub end: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Token {
    pub token_type: ::std::os::raw::c_int,
    pub token_value: *mut ::std::os::raw::c_char,
    pub loc: *mut Loc,
    pub lex_state_before: ::std::os::raw::c_int,
    pub lex_state_after: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TokenList {
    pub len: u32,
    pub list: *mut Token,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DiagnosticMessageType {
    FRACTION_AFTER_NUMERIC = 0,
    NO_DIGITS_AFTER_DOT = 1,
    UNKNOWN_TYPE_OF_PERCENT_STRING = 2,
    NUMERIC_LITERAL_WITHOUT_DIGITS = 3,
    UNTERMINATED_LIST = 4,
    UNTERMINATED_REGEXP = 5,
    UNTERMINATED_STRING = 6,
    UNTERMINATED_QUOTED_STRING = 7,
    INVALID_UNICODE_ESCAPE = 8,
    TOO_LARGE_UNICODE_CODEPOINT = 9,
    INVALID_UNICODE_CODEPOINT = 10,
    MULTIPLE_CODEPOINT_AT_SINGLE_CHAR = 11,
    INVALID_ESCAPE_CHARACTER = 12,
    INVALID_HEX_ESCAPE = 13,
    UNTERMINATED_HEREDOC = 14,
    UNTERMINATED_HEREDOC_ID = 15,
    SLASH_R_AT_MIDDLE_OF_LINE = 16,
    D_STAR_INTERPRETED_AS_ARG_PREFIX = 17,
    STAR_INTERPRETED_AS_ARG_PREFIX = 18,
    AMPERSAND_INTERPRETED_AS_ARG_PREFIX = 19,
    TRIPLE_DOT_AT_EOL = 20,
    PARENTHESES_ITERPRETED_AS_ARGLIST = 21,
    AMBIGUOUS_FIRST_ARGUMENT = 22,
    AMBIGUOUS_OPERATOR = 23,
    INVALID_CHARACTER_SYNTAX = 24,
    INVALID_OCTAL_DIGIT = 25,
    TRAILING_CHAR_IN_NUMBER = 26,
    EMBEDDED_DOCUMENT_MEETS_EOF = 27,
    INVALID_CHAR = 28,
    INCOMPLETE_CHARACTER_SYNTAX = 29,
    GVAR_WITHOUT_ID = 30,
    INVALID_GVAR_NAME = 31,
    IVAR_WITHOUT_ID = 32,
    INVALID_IVAR_NAME = 33,
    CVAR_WITHOUT_ID = 34,
    INVALID_CVAR_NAME = 35,
    UNKNOWN_REGEX_OPTIONS = 36,
    UNTERMINATED_UNICODE_ESCAPE = 37,
    ENCODING_ERROR = 38,
    INVALID_MULTIBYTE_CHAR = 39,
    AMBIGUOUS_TERNARY_OPERATOR = 40,
    AMBIGUOUS_REGEXP = 41,
    ELSE_WITHOUT_RESCUE = 42,
    BEGIN_NOT_AT_TOP_LEVEL = 43,
    ALIAS_NTH_REF = 44,
    CSEND_INSIDE_MASGN = 45,
    CLASS_OR_MODULE_NAME_MUST_BE_CONSTANT = 46,
    ENDLESS_SETTER_DEFINITION = 47,
    UNEXPECTED_TOKEN = 48,
    CLASS_DEFINITION_IN_METHOD_BODY = 49,
    MODULE_DEFINITION_IN_METHOD_BODY = 50,
    INVALID_RETURN_IN_CLASS_OR_MODULE_BODY = 51,
    CONST_ARGUMENT = 52,
    IVAR_ARGUMENT = 53,
    GVAR_ARGUMENT = 54,
    CVAR_ARGUMENT = 55,
    NO_SUCH_LOCAL_VARIABLE = 56,
    ORDINARY_PARAM_DEFINED = 57,
    NUMPARAM_USED = 58,
    TOK_AT_EOL_WITHOUT_EXPRESSION = 59,
    END_IN_METHOD = 60,
    COMPARISON_AFTER_COMPARISON = 61,
    CIRCULAR_ARGUMENT_REFERENCE = 62,
    DYNAMIC_CONSTANT_ASSIGNMENT = 63,
    CANT_ASSIGN_TO_SELF = 64,
    CANT_ASSIGN_TO_NIL = 65,
    CANT_ASSIGN_TO_TRUE = 66,
    CANT_ASSIGN_TO_FALSE = 67,
    CANT_ASSIGN_TO_FILE = 68,
    CANT_ASSIGN_TO_LINE = 69,
    CANT_ASSIGN_TO_ENCODING = 70,
    CANT_ASSIGN_TO_NUMPARAM = 71,
    CANT_SET_VARIABLE = 72,
    BLOCK_GIVEN_TO_YIELD = 73,
    BLOCK_AND_BLOCK_ARG_GIVEN = 74,
    SYMBOL_LITERAL_WITH_INTERPOLATION = 75,
    RESERVED_FOR_NUMPARAM = 76,
    KEY_MUST_BE_VALID_AS_LOCAL_VARIABLE = 77,
    DUPLICATE_VARIABLE_NAME = 78,
    DUPLICATE_KEY_NAME = 79,
    SINGLETON_LITERAL = 80,
    NTH_REF_IS_TOO_BIG = 81,
    DUPLICATED_ARGUMENT_NAME = 82,
    REGEX_ERROR = 83,
    INVALID_SYMBOL = 84,
    VOID_VALUE_EXPRESSION = 85,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UnterminatedHeredoc {
    pub heredoc_id: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AmbiguousFirstArgument {
    pub operator_: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AmbiguousOperator {
    pub operator_: *mut ::std::os::raw::c_char,
    pub interpreted_as: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InvalidCharacterSyntax {
    pub suggestion: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TrailingCharInNumber {
    pub c: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InvalidChar {
    pub c: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InvalidGvarName {
    pub c: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InvalidIvarName {
    pub c: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InvalidCvarName {
    pub c: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UnknownRegexOptions {
    pub options: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EncodingError {
    pub error: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AmbiguousTernaryOperator {
    pub condition: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UnexpectedToken {
    pub token_name: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NoSuchLocalVariable {
    pub var_name: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TokAtEolWithoutExpression {
    pub token_name: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ComparisonAfterComparison {
    pub comparison: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CircularArgumentReference {
    pub arg_name: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CantAssignToNumparam {
    pub numparam: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CantSetVariable {
    pub var_name: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReservedForNumparam {
    pub numparam: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NthRefIsTooBig {
    pub nth_ref: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RegexError {
    pub error: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InvalidSymbol {
    pub symbol: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DiagnosticMessageData {
    pub unterminated_heredoc: UnterminatedHeredoc,
    pub ambiguous_first_argument: AmbiguousFirstArgument,
    pub ambiguous_operator: AmbiguousOperator,
    pub invalid_character_syntax: InvalidCharacterSyntax,
    pub trailing_char_in_number: TrailingCharInNumber,
    pub invalid_char: InvalidChar,
    pub invalid_gvar_name: InvalidGvarName,
    pub invalid_ivar_name: InvalidIvarName,
    pub invalid_cvar_name: InvalidCvarName,
    pub unknown_regex_options: UnknownRegexOptions,
    pub encoding_error: EncodingError,
    pub ambiguous_ternary_operator: AmbiguousTernaryOperator,
    pub unexpected_token: UnexpectedToken,
    pub no_such_local_variable: NoSuchLocalVariable,
    pub tok_at_eol_without_expression: TokAtEolWithoutExpression,
    pub comparison_after_comparison: ComparisonAfterComparison,
    pub circular_argument_reference: CircularArgumentReference,
    pub cant_assign_to_numparam: CantAssignToNumparam,
    pub cant_set_variable: CantSetVariable,
    pub reserved_for_numparam: ReservedForNumparam,
    pub nth_ref_is_too_big: NthRefIsTooBig,
    pub regex_error: RegexError,
    pub invalid_symbol: InvalidSymbol,
    pub other: u32,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DiagnosticMessage {
    pub type_: DiagnosticMessageType,
    pub data: DiagnosticMessageData,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ErrorLevel {
    ERROR_LEVEL_WARNING = 0,
    ERROR_LEVEL_ERROR = 1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Diagnostic {
    pub level: ErrorLevel,
    pub message: DiagnosticMessage,
    pub loc: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DiagnosticList {
    pub len: u32,
    pub list: *mut Diagnostic,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Comment {
    pub location: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CommentList {
    pub len: u32,
    pub list: *mut Comment,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum MagicCommentKind {
    MAGIC_COMMENT_KIND_ENCODING = 0,
    MAGIC_COMMENT_KIND_FROZEN_STRING_LITERAL = 1,
    MAGIC_COMMENT_KIND_WARN_INDENT = 2,
    MAGIC_COMMENT_KIND_SHAREABLE_CONSTANT_VALUE = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MagicComment {
    pub kind: MagicCommentKind,
    pub key_l: *mut Loc,
    pub value_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MagicCommentList {
    pub len: u32,
    pub list: *mut MagicComment,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NodeList {
    pub len: u32,
    pub list: *mut Node,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DecodingStatus {
    DECODING_STATUS_OK = 0,
    DECODING_STATUS_ERROR = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DecoderOutputSuccess {
    pub bytes: *mut ::std::os::raw::c_char,
    pub len: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DecoderOutputError {
    pub error_message: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DecoderOutputValue {
    pub success: DecoderOutputSuccess,
    pub error: DecoderOutputError,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DecoderOutput {
    pub status: DecodingStatus,
    pub value: DecoderOutputValue,
}
pub type CustomDecoderFn = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut ::std::os::raw::c_void,
        encoding: *const ::std::os::raw::c_char,
        input: *const ::std::os::raw::c_char,
        len: u32,
    ) -> DecoderOutput,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomDecoder {
    pub state: *mut ::std::os::raw::c_void,
    pub decoder: CustomDecoderFn,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum TokenRewriteAction {
    REWRITE_ACTION_DROP = 0,
    REWRITE_ACTION_KEEP = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum LexStateActionKind {
    LEX_STATE_ACTION_SET = 0,
    LEX_STATE_ACTION_KEEP = 1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LexStateActionValue {
    pub set: LexStateActionValue__bindgen_ty_1,
    pub keep: LexStateActionValue__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LexStateActionValue__bindgen_ty_1 {
    pub new_state: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LexStateActionValue__bindgen_ty_2 {
    pub dummy: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LexStateAction {
    pub kind: LexStateActionKind,
    pub value: LexStateActionValue,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TokenRewriterOutput {
    pub token: Token,
    pub token_rewriter_action: TokenRewriteAction,
    pub lex_state_action: LexStateAction,
}
pub type TokenRewriterFn = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut ::std::os::raw::c_void,
        token: Token,
        input: *const ::std::os::raw::c_char,
    ) -> TokenRewriterOutput,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TokenRewriter {
    pub state: *mut ::std::os::raw::c_void,
    pub rewriter: TokenRewriterFn,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParserOptions {
    pub buffer_name: *mut ::std::os::raw::c_char,
    pub debug: bool,
    pub decoder: *mut CustomDecoder,
    pub record_tokens: bool,
    pub token_rewriter: *mut TokenRewriter,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParserResult {
    pub ast: *mut Node,
    pub tokens: *mut TokenList,
    pub diagnostics: *mut DiagnosticList,
    pub comments: *mut CommentList,
    pub magic_comments: *mut MagicCommentList,
    pub input: *mut Input,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Alias {
    pub to: *mut Node,
    pub from: *mut Node,
    pub keyword_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AndAsgn {
    pub recv: *mut Node,
    pub value: *mut Node,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct And {
    pub lhs: *mut Node,
    pub rhs: *mut Node,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Arg {
    pub name: *mut ::std::os::raw::c_char,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Args {
    pub args: *mut NodeList,
    pub expression_l: *mut Loc,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Array {
    pub elements: *mut NodeList,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayPattern {
    pub elements: *mut NodeList,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayPatternWithTail {
    pub elements: *mut NodeList,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BackRef {
    pub name: *mut ::std::os::raw::c_char,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Begin {
    pub statements: *mut NodeList,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Block {
    pub call: *mut Node,
    pub args: *mut Node,
    pub body: *mut Node,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BlockPass {
    pub value: *mut Node,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Blockarg {
    pub name: *mut ::std::os::raw::c_char,
    pub operator_l: *mut Loc,
    pub name_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Break {
    pub args: *mut NodeList,
    pub keyword_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Case {
    pub expr: *mut Node,
    pub when_bodies: *mut NodeList,
    pub else_body: *mut Node,
    pub keyword_l: *mut Loc,
    pub else_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CaseMatch {
    pub expr: *mut Node,
    pub in_bodies: *mut NodeList,
    pub else_body: *mut Node,
    pub keyword_l: *mut Loc,
    pub else_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Casgn {
    pub scope: *mut Node,
    pub name: *mut ::std::os::raw::c_char,
    pub value: *mut Node,
    pub double_colon_l: *mut Loc,
    pub name_l: *mut Loc,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Cbase {
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Class {
    pub name: *mut Node,
    pub superclass: *mut Node,
    pub body: *mut Node,
    pub keyword_l: *mut Loc,
    pub operator_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Complex {
    pub value: *mut ::std::os::raw::c_char,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Const {
    pub scope: *mut Node,
    pub name: *mut ::std::os::raw::c_char,
    pub double_colon_l: *mut Loc,
    pub name_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConstPattern {
    pub const_: *mut Node,
    pub pattern: *mut Node,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CSend {
    pub recv: *mut Node,
    pub method_name: *mut ::std::os::raw::c_char,
    pub args: *mut NodeList,
    pub dot_l: *mut Loc,
    pub selector_l: *mut Loc,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Cvar {
    pub name: *mut ::std::os::raw::c_char,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Cvasgn {
    pub name: *mut ::std::os::raw::c_char,
    pub value: *mut Node,
    pub name_l: *mut Loc,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Def {
    pub name: *mut ::std::os::raw::c_char,
    pub args: *mut Node,
    pub body: *mut Node,
    pub keyword_l: *mut Loc,
    pub name_l: *mut Loc,
    pub end_l: *mut Loc,
    pub assignment_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Defined {
    pub value: *mut Node,
    pub keyword_l: *mut Loc,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Defs {
    pub definee: *mut Node,
    pub name: *mut ::std::os::raw::c_char,
    pub args: *mut Node,
    pub body: *mut Node,
    pub keyword_l: *mut Loc,
    pub operator_l: *mut Loc,
    pub name_l: *mut Loc,
    pub assignment_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dstr {
    pub parts: *mut NodeList,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dsym {
    pub parts: *mut NodeList,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EFlipFlop {
    pub left: *mut Node,
    pub right: *mut Node,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EmptyElse {
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Encoding {
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ensure {
    pub body: *mut Node,
    pub ensure: *mut Node,
    pub keyword_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Erange {
    pub left: *mut Node,
    pub right: *mut Node,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct False {
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct File {
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FindPattern {
    pub elements: *mut NodeList,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Float {
    pub value: *mut ::std::os::raw::c_char,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct For {
    pub iterator: *mut Node,
    pub iteratee: *mut Node,
    pub body: *mut Node,
    pub keyword_l: *mut Loc,
    pub operator_l: *mut Loc,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForwardArg {
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForwardedArgs {
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Gvar {
    pub name: *mut ::std::os::raw::c_char,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Gvasgn {
    pub name: *mut ::std::os::raw::c_char,
    pub value: *mut Node,
    pub name_l: *mut Loc,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Hash {
    pub pairs: *mut NodeList,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Kwargs {
    pub pairs: *mut NodeList,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashPattern {
    pub elements: *mut NodeList,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Heredoc {
    pub parts: *mut NodeList,
    pub heredoc_body_l: *mut Loc,
    pub heredoc_end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct If {
    pub cond: *mut Node,
    pub if_true: *mut Node,
    pub if_false: *mut Node,
    pub keyword_l: *mut Loc,
    pub begin_l: *mut Loc,
    pub else_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IfGuard {
    pub cond: *mut Node,
    pub keyword_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IfMod {
    pub cond: *mut Node,
    pub if_true: *mut Node,
    pub if_false: *mut Node,
    pub keyword_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IfTernary {
    pub cond: *mut Node,
    pub if_true: *mut Node,
    pub if_false: *mut Node,
    pub question_l: *mut Loc,
    pub colon_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IFlipFlop {
    pub left: *mut Node,
    pub right: *mut Node,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MatchPattern {
    pub value: *mut Node,
    pub pattern: *mut Node,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MatchPatternP {
    pub value: *mut Node,
    pub pattern: *mut Node,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InPattern {
    pub pattern: *mut Node,
    pub guard: *mut Node,
    pub body: *mut Node,
    pub keyword_l: *mut Loc,
    pub begin_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Index {
    pub recv: *mut Node,
    pub indexes: *mut NodeList,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexAsgn {
    pub recv: *mut Node,
    pub indexes: *mut NodeList,
    pub value: *mut Node,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Int {
    pub value: *mut ::std::os::raw::c_char,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Irange {
    pub left: *mut Node,
    pub right: *mut Node,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ivar {
    pub name: *mut ::std::os::raw::c_char,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ivasgn {
    pub name: *mut ::std::os::raw::c_char,
    pub value: *mut Node,
    pub name_l: *mut Loc,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Kwarg {
    pub name: *mut ::std::os::raw::c_char,
    pub name_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KwBegin {
    pub statements: *mut NodeList,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Kwnilarg {
    pub name_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Kwoptarg {
    pub name: *mut ::std::os::raw::c_char,
    pub default_: *mut Node,
    pub name_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Kwrestarg {
    pub name: *mut ::std::os::raw::c_char,
    pub operator_l: *mut Loc,
    pub name_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Kwsplat {
    pub value: *mut Node,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Lambda {
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Line {
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Lvar {
    pub name: *mut ::std::os::raw::c_char,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Lvasgn {
    pub name: *mut ::std::os::raw::c_char,
    pub value: *mut Node,
    pub name_l: *mut Loc,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Masgn {
    pub lhs: *mut Node,
    pub rhs: *mut Node,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MatchAlt {
    pub lhs: *mut Node,
    pub rhs: *mut Node,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MatchAs {
    pub value: *mut Node,
    pub as_: *mut Node,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MatchCurrentLine {
    pub re: *mut Node,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MatchNilPattern {
    pub operator_l: *mut Loc,
    pub name_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MatchRest {
    pub name: *mut Node,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MatchVar {
    pub name: *mut ::std::os::raw::c_char,
    pub name_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MatchWithLvasgn {
    pub re: *mut Node,
    pub value: *mut Node,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Mlhs {
    pub items: *mut NodeList,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Module {
    pub name: *mut Node,
    pub body: *mut Node,
    pub keyword_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Next {
    pub args: *mut NodeList,
    pub keyword_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Nil {
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NthRef {
    pub name: *mut ::std::os::raw::c_char,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Numblock {
    pub call: *mut Node,
    pub numargs: u32,
    pub body: *mut Node,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpAsgn {
    pub recv: *mut Node,
    pub operator: *mut ::std::os::raw::c_char,
    pub value: *mut Node,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Optarg {
    pub name: *mut ::std::os::raw::c_char,
    pub default_: *mut Node,
    pub name_l: *mut Loc,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Or {
    pub lhs: *mut Node,
    pub rhs: *mut Node,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrAsgn {
    pub recv: *mut Node,
    pub value: *mut Node,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pair {
    pub key: *mut Node,
    pub value: *mut Node,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pin {
    pub var: *mut Node,
    pub selector_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Postexe {
    pub body: *mut Node,
    pub keyword_l: *mut Loc,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Preexe {
    pub body: *mut Node,
    pub keyword_l: *mut Loc,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Procarg0 {
    pub args: *mut NodeList,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rational {
    pub value: *mut ::std::os::raw::c_char,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Redo {
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RegOpt {
    pub options: *mut ::std::os::raw::c_char,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Regexp {
    pub parts: *mut NodeList,
    pub options: *mut Node,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rescue {
    pub body: *mut Node,
    pub rescue_bodies: *mut NodeList,
    pub else_: *mut Node,
    pub else_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RescueBody {
    pub exc_list: *mut Node,
    pub exc_var: *mut Node,
    pub body: *mut Node,
    pub keyword_l: *mut Loc,
    pub assoc_l: *mut Loc,
    pub begin_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Restarg {
    pub name: *mut ::std::os::raw::c_char,
    pub operator_l: *mut Loc,
    pub name_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Retry {
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Return {
    pub args: *mut NodeList,
    pub keyword_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SClass {
    pub expr: *mut Node,
    pub body: *mut Node,
    pub keyword_l: *mut Loc,
    pub operator_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Self_ {
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Send {
    pub recv: *mut Node,
    pub method_name: *mut ::std::os::raw::c_char,
    pub args: *mut NodeList,
    pub dot_l: *mut Loc,
    pub selector_l: *mut Loc,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Shadowarg {
    pub name: *mut ::std::os::raw::c_char,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Splat {
    pub value: *mut Node,
    pub operator_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Str {
    pub value: *mut ::std::os::raw::c_char,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Super {
    pub args: *mut NodeList,
    pub keyword_l: *mut Loc,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sym {
    pub name: *mut ::std::os::raw::c_char,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct True {
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Undef {
    pub names: *mut NodeList,
    pub keyword_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UnlessGuard {
    pub cond: *mut Node,
    pub keyword_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Until {
    pub cond: *mut Node,
    pub body: *mut Node,
    pub keyword_l: *mut Loc,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UntilPost {
    pub cond: *mut Node,
    pub body: *mut Node,
    pub keyword_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct When {
    pub patterns: *mut NodeList,
    pub body: *mut Node,
    pub keyword_l: *mut Loc,
    pub begin_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct While {
    pub cond: *mut Node,
    pub body: *mut Node,
    pub keyword_l: *mut Loc,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WhilePost {
    pub cond: *mut Node,
    pub body: *mut Node,
    pub keyword_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XHeredoc {
    pub parts: *mut NodeList,
    pub heredoc_body_l: *mut Loc,
    pub heredoc_end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Xstr {
    pub parts: *mut NodeList,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Yield {
    pub args: *mut NodeList,
    pub keyword_l: *mut Loc,
    pub begin_l: *mut Loc,
    pub end_l: *mut Loc,
    pub expression_l: *mut Loc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSuper {
    pub expression_l: *mut Loc,
}
pub const NodeType_NODE_ALIAS: NodeType = 0;
pub const NodeType_NODE_AND_ASGN: NodeType = 1;
pub const NodeType_NODE_AND: NodeType = 2;
pub const NodeType_NODE_ARG: NodeType = 3;
pub const NodeType_NODE_ARGS: NodeType = 4;
pub const NodeType_NODE_ARRAY: NodeType = 5;
pub const NodeType_NODE_ARRAY_PATTERN: NodeType = 6;
pub const NodeType_NODE_ARRAY_PATTERN_WITH_TAIL: NodeType = 7;
pub const NodeType_NODE_BACK_REF: NodeType = 8;
pub const NodeType_NODE_BEGIN: NodeType = 9;
pub const NodeType_NODE_BLOCK: NodeType = 10;
pub const NodeType_NODE_BLOCK_PASS: NodeType = 11;
pub const NodeType_NODE_BLOCKARG: NodeType = 12;
pub const NodeType_NODE_BREAK_: NodeType = 13;
pub const NodeType_NODE_CASE: NodeType = 14;
pub const NodeType_NODE_CASE_MATCH: NodeType = 15;
pub const NodeType_NODE_CASGN: NodeType = 16;
pub const NodeType_NODE_CBASE: NodeType = 17;
pub const NodeType_NODE_CLASS: NodeType = 18;
pub const NodeType_NODE_COMPLEX: NodeType = 19;
pub const NodeType_NODE_CONST_: NodeType = 20;
pub const NodeType_NODE_CONST_PATTERN: NodeType = 21;
pub const NodeType_NODE_CSEND: NodeType = 22;
pub const NodeType_NODE_CVAR: NodeType = 23;
pub const NodeType_NODE_CVASGN: NodeType = 24;
pub const NodeType_NODE_DEF: NodeType = 25;
pub const NodeType_NODE_DEFINED: NodeType = 26;
pub const NodeType_NODE_DEFS: NodeType = 27;
pub const NodeType_NODE_DSTR: NodeType = 28;
pub const NodeType_NODE_DSYM: NodeType = 29;
pub const NodeType_NODE_EFLIPFLOP: NodeType = 30;
pub const NodeType_NODE_EMPTY_ELSE: NodeType = 31;
pub const NodeType_NODE_ENCODING_: NodeType = 32;
pub const NodeType_NODE_ENSURE: NodeType = 33;
pub const NodeType_NODE_ERANGE: NodeType = 34;
pub const NodeType_NODE_FALSE_: NodeType = 35;
pub const NodeType_NODE_FILE: NodeType = 36;
pub const NodeType_NODE_FIND_PATTERN: NodeType = 37;
pub const NodeType_NODE_FLOAT: NodeType = 38;
pub const NodeType_NODE_FOR_: NodeType = 39;
pub const NodeType_NODE_FORWARD_ARG: NodeType = 40;
pub const NodeType_NODE_FORWARDED_ARGS: NodeType = 41;
pub const NodeType_NODE_GVAR: NodeType = 42;
pub const NodeType_NODE_GVASGN: NodeType = 43;
pub const NodeType_NODE_HASH: NodeType = 44;
pub const NodeType_NODE_KWARGS: NodeType = 45;
pub const NodeType_NODE_HASH_PATTERN: NodeType = 46;
pub const NodeType_NODE_HEREDOC: NodeType = 47;
pub const NodeType_NODE_IF_: NodeType = 48;
pub const NodeType_NODE_IF_GUARD: NodeType = 49;
pub const NodeType_NODE_IF_MOD: NodeType = 50;
pub const NodeType_NODE_IF_TERNARY: NodeType = 51;
pub const NodeType_NODE_IFLIPFLOP: NodeType = 52;
pub const NodeType_NODE_MATCH_PATTERN: NodeType = 53;
pub const NodeType_NODE_MATCH_PATTERN_P: NodeType = 54;
pub const NodeType_NODE_IN_PATTERN: NodeType = 55;
pub const NodeType_NODE_INDEX: NodeType = 56;
pub const NodeType_NODE_INDEX_ASGN: NodeType = 57;
pub const NodeType_NODE_INT: NodeType = 58;
pub const NodeType_NODE_IRANGE: NodeType = 59;
pub const NodeType_NODE_IVAR: NodeType = 60;
pub const NodeType_NODE_IVASGN: NodeType = 61;
pub const NodeType_NODE_KWARG: NodeType = 62;
pub const NodeType_NODE_KWBEGIN: NodeType = 63;
pub const NodeType_NODE_KWNILARG: NodeType = 64;
pub const NodeType_NODE_KWOPTARG: NodeType = 65;
pub const NodeType_NODE_KWRESTARG: NodeType = 66;
pub const NodeType_NODE_KWSPLAT: NodeType = 67;
pub const NodeType_NODE_LAMBDA: NodeType = 68;
pub const NodeType_NODE_LINE: NodeType = 69;
pub const NodeType_NODE_LVAR: NodeType = 70;
pub const NodeType_NODE_LVASGN: NodeType = 71;
pub const NodeType_NODE_MASGN: NodeType = 72;
pub const NodeType_NODE_MATCH_ALT: NodeType = 73;
pub const NodeType_NODE_MATCH_AS: NodeType = 74;
pub const NodeType_NODE_MATCH_CURRENT_LINE: NodeType = 75;
pub const NodeType_NODE_MATCH_NIL_PATTERN: NodeType = 76;
pub const NodeType_NODE_MATCH_REST: NodeType = 77;
pub const NodeType_NODE_MATCH_VAR: NodeType = 78;
pub const NodeType_NODE_MATCH_WITH_LVASGN: NodeType = 79;
pub const NodeType_NODE_MLHS: NodeType = 80;
pub const NodeType_NODE_MODULE: NodeType = 81;
pub const NodeType_NODE_NEXT: NodeType = 82;
pub const NodeType_NODE_NIL: NodeType = 83;
pub const NodeType_NODE_NTH_REF: NodeType = 84;
pub const NodeType_NODE_NUMBLOCK: NodeType = 85;
pub const NodeType_NODE_OP_ASGN: NodeType = 86;
pub const NodeType_NODE_OPTARG: NodeType = 87;
pub const NodeType_NODE_OR: NodeType = 88;
pub const NodeType_NODE_OR_ASGN: NodeType = 89;
pub const NodeType_NODE_PAIR: NodeType = 90;
pub const NodeType_NODE_PIN: NodeType = 91;
pub const NodeType_NODE_POSTEXE: NodeType = 92;
pub const NodeType_NODE_PREEXE: NodeType = 93;
pub const NodeType_NODE_PROCARG0: NodeType = 94;
pub const NodeType_NODE_RATIONAL: NodeType = 95;
pub const NodeType_NODE_REDO: NodeType = 96;
pub const NodeType_NODE_REG_OPT: NodeType = 97;
pub const NodeType_NODE_REGEXP: NodeType = 98;
pub const NodeType_NODE_RESCUE: NodeType = 99;
pub const NodeType_NODE_RESCUE_BODY: NodeType = 100;
pub const NodeType_NODE_RESTARG: NodeType = 101;
pub const NodeType_NODE_RETRY: NodeType = 102;
pub const NodeType_NODE_RETURN_: NodeType = 103;
pub const NodeType_NODE_SCLASS: NodeType = 104;
pub const NodeType_NODE_SELF_: NodeType = 105;
pub const NodeType_NODE_SEND: NodeType = 106;
pub const NodeType_NODE_SHADOWARG: NodeType = 107;
pub const NodeType_NODE_SPLAT: NodeType = 108;
pub const NodeType_NODE_STR_: NodeType = 109;
pub const NodeType_NODE_SUPER_: NodeType = 110;
pub const NodeType_NODE_SYM: NodeType = 111;
pub const NodeType_NODE_TRUE_: NodeType = 112;
pub const NodeType_NODE_UNDEF: NodeType = 113;
pub const NodeType_NODE_UNLESS_GUARD: NodeType = 114;
pub const NodeType_NODE_UNTIL: NodeType = 115;
pub const NodeType_NODE_UNTIL_POST: NodeType = 116;
pub const NodeType_NODE_WHEN: NodeType = 117;
pub const NodeType_NODE_WHILE_: NodeType = 118;
pub const NodeType_NODE_WHILE_POST: NodeType = 119;
pub const NodeType_NODE_X_HEREDOC: NodeType = 120;
pub const NodeType_NODE_XSTR: NodeType = 121;
pub const NodeType_NODE_YIELD_: NodeType = 122;
pub const NodeType_NODE_ZSUPER: NodeType = 123;
pub type NodeType = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union InnerNode {
    pub _alias: *mut Alias,
    pub _and_asgn: *mut AndAsgn,
    pub _and: *mut And,
    pub _arg: *mut Arg,
    pub _args: *mut Args,
    pub _array: *mut Array,
    pub _array_pattern: *mut ArrayPattern,
    pub _array_pattern_with_tail: *mut ArrayPatternWithTail,
    pub _back_ref: *mut BackRef,
    pub _begin: *mut Begin,
    pub _block: *mut Block,
    pub _block_pass: *mut BlockPass,
    pub _blockarg: *mut Blockarg,
    pub _break_: *mut Break,
    pub _case: *mut Case,
    pub _case_match: *mut CaseMatch,
    pub _casgn: *mut Casgn,
    pub _cbase: *mut Cbase,
    pub _class: *mut Class,
    pub _complex: *mut Complex,
    pub _const_: *mut Const,
    pub _const_pattern: *mut ConstPattern,
    pub _csend: *mut CSend,
    pub _cvar: *mut Cvar,
    pub _cvasgn: *mut Cvasgn,
    pub _def: *mut Def,
    pub _defined: *mut Defined,
    pub _defs: *mut Defs,
    pub _dstr: *mut Dstr,
    pub _dsym: *mut Dsym,
    pub _eflipflop: *mut EFlipFlop,
    pub _empty_else: *mut EmptyElse,
    pub _encoding_: *mut Encoding,
    pub _ensure: *mut Ensure,
    pub _erange: *mut Erange,
    pub _false_: *mut False,
    pub _file: *mut File,
    pub _find_pattern: *mut FindPattern,
    pub _float: *mut Float,
    pub _for_: *mut For,
    pub _forward_arg: *mut ForwardArg,
    pub _forwarded_args: *mut ForwardedArgs,
    pub _gvar: *mut Gvar,
    pub _gvasgn: *mut Gvasgn,
    pub _hash: *mut Hash,
    pub _kwargs: *mut Kwargs,
    pub _hash_pattern: *mut HashPattern,
    pub _heredoc: *mut Heredoc,
    pub _if_: *mut If,
    pub _if_guard: *mut IfGuard,
    pub _if_mod: *mut IfMod,
    pub _if_ternary: *mut IfTernary,
    pub _iflipflop: *mut IFlipFlop,
    pub _match_pattern: *mut MatchPattern,
    pub _match_pattern_p: *mut MatchPatternP,
    pub _in_pattern: *mut InPattern,
    pub _index: *mut Index,
    pub _index_asgn: *mut IndexAsgn,
    pub _int: *mut Int,
    pub _irange: *mut Irange,
    pub _ivar: *mut Ivar,
    pub _ivasgn: *mut Ivasgn,
    pub _kwarg: *mut Kwarg,
    pub _kwbegin: *mut KwBegin,
    pub _kwnilarg: *mut Kwnilarg,
    pub _kwoptarg: *mut Kwoptarg,
    pub _kwrestarg: *mut Kwrestarg,
    pub _kwsplat: *mut Kwsplat,
    pub _lambda: *mut Lambda,
    pub _line: *mut Line,
    pub _lvar: *mut Lvar,
    pub _lvasgn: *mut Lvasgn,
    pub _masgn: *mut Masgn,
    pub _match_alt: *mut MatchAlt,
    pub _match_as: *mut MatchAs,
    pub _match_current_line: *mut MatchCurrentLine,
    pub _match_nil_pattern: *mut MatchNilPattern,
    pub _match_rest: *mut MatchRest,
    pub _match_var: *mut MatchVar,
    pub _match_with_lvasgn: *mut MatchWithLvasgn,
    pub _mlhs: *mut Mlhs,
    pub _module: *mut Module,
    pub _next: *mut Next,
    pub _nil: *mut Nil,
    pub _nth_ref: *mut NthRef,
    pub _numblock: *mut Numblock,
    pub _op_asgn: *mut OpAsgn,
    pub _optarg: *mut Optarg,
    pub _or: *mut Or,
    pub _or_asgn: *mut OrAsgn,
    pub _pair: *mut Pair,
    pub _pin: *mut Pin,
    pub _postexe: *mut Postexe,
    pub _preexe: *mut Preexe,
    pub _procarg0: *mut Procarg0,
    pub _rational: *mut Rational,
    pub _redo: *mut Redo,
    pub _reg_opt: *mut RegOpt,
    pub _regexp: *mut Regexp,
    pub _rescue: *mut Rescue,
    pub _rescue_body: *mut RescueBody,
    pub _restarg: *mut Restarg,
    pub _retry: *mut Retry,
    pub _return_: *mut Return,
    pub _sclass: *mut SClass,
    pub _self_: *mut Self_,
    pub _send: *mut Send,
    pub _shadowarg: *mut Shadowarg,
    pub _splat: *mut Splat,
    pub _str_: *mut Str,
    pub _super_: *mut Super,
    pub _sym: *mut Sym,
    pub _true_: *mut True,
    pub _undef: *mut Undef,
    pub _unless_guard: *mut UnlessGuard,
    pub _until: *mut Until,
    pub _until_post: *mut UntilPost,
    pub _when: *mut When,
    pub _while_: *mut While,
    pub _while_post: *mut WhilePost,
    pub _x_heredoc: *mut XHeredoc,
    pub _xstr: *mut Xstr,
    pub _yield_: *mut Yield,
    pub _zsuper: *mut ZSuper,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Node {
    pub node_type: NodeType,
    pub inner: *mut InnerNode,
}
