use lib_ruby_parser_nodes::{template::*, NodeField};

const TEMPLATE: &str = "// This file is autogenerated by {{ helper generated-by }}

#[allow(unused_imports)]
use lib_ruby_parser::{Node, nodes::*, Loc, Bytes};
use crate::blob_type;

blob_type!(NodeBlob, Node);
blob_type!(BlobNodeList, Vec<Node>);

#[cfg(feature = \"tests\")]
mod helpers {
    use super::*;

    pub(crate) fn make_node() -> Box<Node> {
        Box::new(Node::Line(Line { expression_l: make_loc() }))
    }
    pub(crate) fn make_nodes() -> Vec<Node> {
        vec![*make_node()]
    }
    pub(crate) fn make_maybe_node() -> Option<Box<Node>> {
        Some(make_node())
    }
    pub(crate) fn make_loc() -> Loc {
        Loc { begin: 1, end: 2 }
    }
    pub(crate) fn make_maybe_loc() -> Option<Loc> {
        Some(make_loc())
    }
    pub(crate) fn make_str() -> String {
        String::from(\"foo\")
    }
    pub(crate) fn make_maybe_str() -> Option<String> {
        Some(make_str())
    }
    pub(crate) fn make_string_value() -> Bytes {
        Bytes::new(vec![1, 2, 3])
    }
    pub(crate) fn make_u8() -> u8 {
        42
    }
}

{{ each node }}<dnl>
#[cfg(feature = \"tests\")]
#[no_mangle]
pub extern \"C\" fn lib_ruby_parser__test__make_{{ helper node-lower-name }}_node() -> NodeBlob {
    NodeBlob::from(
        Node::{{ helper node-camelcase-name }}({{ helper node-camelcase-name }} {
{{ each node-field }}<dnl>
            {{ helper rust-node-field-name }}: helpers::{{ helper make-field-fn }}(),
{{ end }}<dnl>
        })
    )
}
{{ end }}<dnl>

{{ each node }}<dnl>
#[no_mangle]
pub extern \"C\" fn LIB_RUBY_PARSER_drop_node_{{ helper node-lower-name }}(variant: *mut {{ helper node-camelcase-name }}) {
    unsafe { std::ptr::drop_in_place(variant) }
}
{{ end }}<dnl>

#[no_mangle]
pub extern \"C\" fn LIB_RUBY_PARSER_drop_node(node: *mut Node) {
    unsafe { std::ptr::drop_in_place(node) }
}

#[cfg(feature = \"tests\")]
#[no_mangle]
pub extern \"C\" fn lib_ruby_parser__test__make_node_list() -> BlobNodeList {
    BlobNodeList::from(helpers::make_nodes())
}

#[no_mangle]
pub extern \"C\" fn LIB_RUBY_PARSER_drop_node_list(node_list: *mut Vec<Node>) {
    unsafe { std::ptr::drop_in_place(node_list) }
}
";

pub(crate) fn codegen() {
    let template = TemplateRoot::new(TEMPLATE).unwrap();
    let mut fns = crate::codegen::fns::default_fns!();

    fns.register::<NodeField, F::Helper>("make-field-fn", helpers::make_field_fn);
    fns.register::<NodeField, F::Helper>("rust-node-field-name", helpers::rust_node_field_name);

    let contents = template.render(ALL_DATA, &fns);
    std::fs::write("../ruby-parser-c/src/node.rs", contents).unwrap();
}

mod helpers {
    use lib_ruby_parser_nodes::NodeField;

    pub(crate) fn make_field_fn(node_field: &NodeField) -> String {
        use lib_ruby_parser_nodes::NodeFieldType::*;

        match node_field.field_type {
            Node => "make_node",
            Nodes => "make_nodes",
            MaybeNode { .. } => "make_maybe_node",
            Loc => "make_loc",
            MaybeLoc => "make_maybe_loc",
            Str { .. } => "make_str",
            MaybeStr { .. } => "make_maybe_str",
            StringValue => "make_string_value",
            U8 => "make_u8",
        }
        .to_string()
    }

    pub(crate) fn rust_node_field_name(node_field: &NodeField) -> String {
        match &node_field.snakecase_name[..] {
            "const" => "const_",
            "as" => "as_",
            "else" => "else_",
            other => other,
        }
        .to_string()
    }
}
