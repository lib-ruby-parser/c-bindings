use lib_ruby_parser_nodes::{template::*, NodeField};

const TEMPLATE: &str = "// This file is autogenerated by {{ helper generated-by }}

#include \"nodes.h\"

#ifdef TEST_ENV

#include \"test_helper.h\"

#define assert_expected_node_value(node) \\
    assert_eq((node)->tag, LIB_RUBY_PARSER_NODE_LINE)

#define assert_expected_nodes_value(nodes) \\
    assert_eq((nodes).len, 1); \\
    assert_expected_node_value(&((nodes).ptr[0]))

#define assert_expected_maybe_node_value(maybe_node) \\
    assert_expected_node_value(maybe_node)

#define assert_expected_loc_value(loc) \\
    assert_eq((loc).begin, 1); \\
    assert_eq((loc).end, 2)

#define assert_expected_maybe_loc_value(maybe_loc) \\
    assert_eq((maybe_loc).tag, LIB_RUBY_PARSER_SOME_LOC); \\
    assert_eq((maybe_loc).as.loc.begin, 1); \\
    assert_eq((maybe_loc).as.loc.end, 2)

#define assert_expected_str_value(str) \\
    assert_string_eq((str), \"foo\")

#define assert_expected_maybe_str_value(maybe_str) \\
    assert_string_eq((maybe_str).string, \"foo\")

#define assert_expected_string_value_value(string_value) \\
    assert_byte_list((string_value).raw, \"\\1\\2\\3\")

#define assert_expected_u8_value(u8) \\
    assert_eq((u8), 42)

{{ each node }}<dnl>
LIB_RUBY_PARSER_Node lib_ruby_parser__test__make_{{ helper node-lower-name }}_node(void);
static void test_node_{{ helper node-lower-name }}(void)
{
    annotate_test;
    LIB_RUBY_PARSER_Node node;

    node = lib_ruby_parser__test__make_{{ helper node-lower-name }}_node();
    assert_eq(node.tag, {{ helper node-c-enum-variant-name }});
    LIB_RUBY_PARSER_{{ helper node-camelcase-name }} variant = node.as.{{ helper node-c-union-member-name }};
{{ each node-field }}<dnl>
    {{ helper assert-field-fn }}(variant.{{ helper node-field-c-name }});
{{ end }}<dnl>
    LIB_RUBY_PARSER_drop_node_{{ helper node-lower-name }}(&variant);

    node = lib_ruby_parser__test__make_{{ helper node-lower-name }}_node();
    LIB_RUBY_PARSER_drop_node(&node);
}
{{ end }}<dnl>

LIB_RUBY_PARSER_NodeList lib_ruby_parser__test__make_node_list(void);
static void test_node_list(void)
{
    annotate_test;

    LIB_RUBY_PARSER_NodeList node_list = lib_ruby_parser__test__make_node_list();
    assert_expected_nodes_value(node_list);
    LIB_RUBY_PARSER_drop_node_list(&node_list);
}

void run_test_group_node(void)
{
    const test_fn_t tests[] = {
{{ each node }}<dnl>
        test_node_{{ helper node-lower-name }},
{{ end }}<dnl>
        test_node_list,
    };

    run_tests_as_group(\"node\", tests, sizeof(tests) / sizeof(test_fn_t));
}

#endif
";

pub(crate) fn codegen() {
    let template = TemplateRoot::new(TEMPLATE).unwrap();
    let mut fns = crate::codegen::fns::default_fns!();

    fns.register::<NodeField, F::Helper>("assert-field-fn", helpers::assert_field_fn);

    let contents = template.render(ALL_DATA, &fns);
    std::fs::write("../nodes.c", contents).unwrap();
}

mod helpers {
    use lib_ruby_parser_nodes::NodeField;

    pub(crate) fn assert_field_fn(node_field: &NodeField) -> String {
        use lib_ruby_parser_nodes::NodeFieldType::*;

        match node_field.field_type {
            Node => "assert_expected_node_value",
            Nodes => "assert_expected_nodes_value",
            MaybeNode { .. } => "assert_expected_maybe_node_value",
            Loc => "assert_expected_loc_value",
            MaybeLoc => "assert_expected_maybe_loc_value",
            Str { .. } => "assert_expected_str_value",
            MaybeStr { .. } => "assert_expected_maybe_str_value",
            StringValue => "assert_expected_string_value_value",
            U8 => "assert_expected_u8_value",
        }
        .to_string()
    }
}
